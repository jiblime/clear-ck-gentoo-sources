From a5155e932d77dc479f65c721f70c8467b029ebab Mon Sep 17 00:00:00 2001
From: jiblime <47689567+jiblime@users.noreply.github.com>
Date: Mon, 7 Oct 2019 19:55:34 -0700
Subject: [PATCH 3/6] Working GCOV/PGO patchset

---
 Makefile                              |  27 +
 arch/arm64/kvm/hyp/Makefile           |   1 +
 arch/s390/kernel/Makefile             |   4 +-
 arch/s390/kernel/vdso32/Makefile      |   1 +
 arch/s390/kernel/vdso64/Makefile      |   1 +
 arch/um/kernel/Makefile               |   1 +
 arch/um/os-Linux/Makefile             |   1 +
 arch/x86/Makefile                     |   3 +
 arch/x86/boot/Makefile                |   1 +
 arch/x86/boot/compressed/Makefile     |   1 +
 arch/x86/crypto/Makefile              |   2 +
 arch/x86/entry/Makefile               |   2 +-
 arch/x86/entry/vdso/Makefile          |   1 +
 arch/x86/events/Makefile              |   1 +
 arch/x86/events/intel/Makefile        |   1 +
 arch/x86/kernel/Makefile              |   1 +
 arch/x86/kernel/apic/Makefile         |   1 +
 arch/x86/kernel/cpu/Makefile          |   2 +
 arch/x86/kernel/paravirt.c            |   6 +-
 arch/x86/kvm/Makefile                 |   2 +-
 arch/x86/lib/Makefile                 |   3 +
 arch/x86/mm/Makefile                  |   6 +-
 arch/x86/purgatory/Makefile           |   1 +
 arch/x86/realmode/rm/Makefile         |   1 +
 arch/x86/um/vdso/Makefile             |   1 +
 block/Makefile                        |   2 +-
 crypto/Makefile                       |   3 +-
 crypto/jitterentropy.c                |   4 +-
 drivers/Makefile                      |   2 +-
 drivers/firmware/efi/libstub/Makefile |   1 +
 fs/Makefile                           |   2 +-
 init/Makefile                         |   3 +
 ipc/Makefile                          |   2 +-
 kernel/Makefile                       |   6 +-
 kernel/gcov/Kconfig                   |  22 +
 kernel/gcov/Makefile                  |  44 +-
 kernel/gcov/base.c                    | 264 ++++++++-
 kernel/gcov/gcc_4_7.c                 |  93 +++-
 kernel/gcov/gcc_4_9.c                 | 764 ++++++++++++++++++++++++++
 kernel/gcov/gcov.h                    |  43 +-
 lib/Makefile                          |   7 +
 mm/Makefile                           |   1 +
 mm/kasan/Makefile                     |   1 +
 net/Makefile                          |   2 +-
 scripts/gcov/buildGCOVKernel          |  38 ++
 scripts/gcov/calcsum-4.9.cpp          | 258 +++++++++
 scripts/gcov/gather.sh                |  25 +
 scripts/gcov/gathergcno.sh            |  18 +
 scripts/gcov/genPGOKernel             | 116 ++++
 scripts/gcov/mergegcov.sh             |  49 ++
 scripts/gcov/processGCOVMakefiles     |   3 +
 scripts/gcov/rename.sh                |   4 +
 sound/Makefile                        |   2 +-
 virt/Makefile                         |   1 +
 54 files changed, 1815 insertions(+), 37 deletions(-)
 create mode 100644 kernel/gcov/gcc_4_9.c
 create mode 100755 scripts/gcov/buildGCOVKernel
 create mode 100644 scripts/gcov/calcsum-4.9.cpp
 create mode 100755 scripts/gcov/gather.sh
 create mode 100755 scripts/gcov/gathergcno.sh
 create mode 100755 scripts/gcov/genPGOKernel
 create mode 100755 scripts/gcov/mergegcov.sh
 create mode 100755 scripts/gcov/processGCOVMakefiles
 create mode 100755 scripts/gcov/rename.sh

diff --git a/Makefile b/Makefile
index 728cc2cbb..f714fc964 100644
--- a/Makefile
+++ b/Makefile
@@ -402,6 +402,15 @@ LDFLAGS_MODULE  =
 CFLAGS_KERNEL	=
 AFLAGS_KERNEL	=
 LDFLAGS_vmlinux =
+CFLAGS_GCOV	= -fprofile-generate=/tmp/kernelPGO -fprofile-update=atomic \
+		-fprofile-dir=/tmp/kernelPGO -fprofile-values \
+		-finline-functions -fprofile-reorder-functions \
+		-freorder-blocks-and-partition -fipa-profile -fvpt \
+		-fipa-cp -fipa-cp-clone -fipa-pta -fpeel-loops \
+		-ftree-partial-pre \
+		-fschedule-insns -fsched-pressure -fgraphite-identity -floop-nest-optimize \
+		-fsched-stalled-insns=4 -fsched-stalled-insns-dep=32
+
 
 # Use USERINCLUDE when you must reference the UAPI directories only.
 USERINCLUDE    := \
@@ -427,6 +436,13 @@ KBUILD_CFLAGS   := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
 		   -Wno-format-security \
 		   -std=gnu89
 KBUILD_CPPFLAGS := -D__KERNEL__
+
+ifdef CONFIG_GCOV_KERNEL
+    LDFLAGS_MODULE	+= $(call cc-option,-fprofile-generate) \
+			$(call cc-option,-fprofile-update=atomic)
+    LDFLAGS_vmlinux	+= $(call cc-option,-fprofile-generate) \
+			$(call cc-option,-fprofile-update=atomic)
+endif
 KBUILD_AFLAGS_KERNEL :=
 KBUILD_CFLAGS_KERNEL :=
 KBUILD_AFLAGS_MODULE  := -DMODULE
@@ -672,6 +688,17 @@ KBUILD_CFLAGS   += -O2
 endif
 endif
 
+# Enable GCC PGO + some additional optimizations if requested.
+ifdef CONFIG_GCOV_PGO_ENABLE
+KBUILD_CFLAGS	+= -fprofile-use=/tmp/kernelPGO -fprofile-dir=/tmp/kernelPGO \
+		-finline-functions -fprofile-reorder-functions -fprofile-values \
+		-freorder-blocks-and-partition -fipa-profile -fvpt \
+		-fipa-cp -fipa-cp-clone -fipa-pta -fpeel-loops \
+		-ftree-partial-pre -fprofile-correction \
+		-fschedule-insns -fsched-pressure -fgraphite-identity -floop-nest-optimize \
+		-fsched-stalled-insns=4 -fsched-stalled-insns-dep=32
+endif
+
 KBUILD_CFLAGS += $(call cc-ifversion, -lt, 0409, \
 			$(call cc-disable-warning,maybe-uninitialized,))
 
diff --git a/arch/arm64/kvm/hyp/Makefile b/arch/arm64/kvm/hyp/Makefile
index 2fabc2dc1..315008894 100644
--- a/arch/arm64/kvm/hyp/Makefile
+++ b/arch/arm64/kvm/hyp/Makefile
@@ -28,3 +28,4 @@ GCOV_PROFILE	:= n
 KASAN_SANITIZE	:= n
 UBSAN_SANITIZE	:= n
 KCOV_INSTRUMENT	:= n
+GCOV_PROFILE	:= n
diff --git a/arch/s390/kernel/Makefile b/arch/s390/kernel/Makefile
index dbfd1730e..e990a1ede 100644
--- a/arch/s390/kernel/Makefile
+++ b/arch/s390/kernel/Makefile
@@ -17,8 +17,10 @@ endif
 GCOV_PROFILE_early.o		:= n
 GCOV_PROFILE_early_nobss.o	:= n
 
+GCOV_PROFILE_als.o	:= n
 KCOV_INSTRUMENT_early.o		:= n
-KCOV_INSTRUMENT_early_nobss.o	:= n
+GCOV_PROFILE_early.o	:= n
+GCOV_PROFILE_sclp.o	:= n
 
 UBSAN_SANITIZE_early.o		:= n
 UBSAN_SANITIZE_early_nobss.o	:= n
diff --git a/arch/s390/kernel/vdso32/Makefile b/arch/s390/kernel/vdso32/Makefile
index 04dd3e2c3..f47cceb15 100644
--- a/arch/s390/kernel/vdso32/Makefile
+++ b/arch/s390/kernel/vdso32/Makefile
@@ -2,6 +2,7 @@
 # List of files in the vdso, has to be asm only for now
 
 KCOV_INSTRUMENT := n
+GCOV_PROFILE := n
 
 obj-vdso32 = gettimeofday.o clock_getres.o clock_gettime.o note.o getcpu.o
 
diff --git a/arch/s390/kernel/vdso64/Makefile b/arch/s390/kernel/vdso64/Makefile
index ddebc26cd..62151cd31 100644
--- a/arch/s390/kernel/vdso64/Makefile
+++ b/arch/s390/kernel/vdso64/Makefile
@@ -2,6 +2,7 @@
 # List of files in the vdso, has to be asm only for now
 
 KCOV_INSTRUMENT := n
+GCOV_PROFILE := n
 
 obj-vdso64 = gettimeofday.o clock_getres.o clock_gettime.o note.o getcpu.o
 
diff --git a/arch/um/kernel/Makefile b/arch/um/kernel/Makefile
index 2f36d5157..642238a02 100644
--- a/arch/um/kernel/Makefile
+++ b/arch/um/kernel/Makefile
@@ -7,6 +7,7 @@
 # accessing the instrumentation buffer for the first time from the
 # kernel.
 KCOV_INSTRUMENT                := n
+GCOV_PROFILE                := n
 
 CPPFLAGS_vmlinux.lds := -DSTART=$(LDS_START)		\
                         -DELF_ARCH=$(LDS_ELF_ARCH)	\
diff --git a/arch/um/os-Linux/Makefile b/arch/um/os-Linux/Makefile
index ada473bf6..bc57e85ca 100644
--- a/arch/um/os-Linux/Makefile
+++ b/arch/um/os-Linux/Makefile
@@ -5,6 +5,7 @@
 
 # Don't instrument UML-specific code
 KCOV_INSTRUMENT                := n
+GCOV_PROFILE                := n
 
 obj-y = aio.o execvp.o file.o helper.o irq.o main.o mem.o process.o \
 	registers.o sigio.o signal.o start_up.o time.o tty.o \
diff --git a/arch/x86/Makefile b/arch/x86/Makefile
index 8f6e7eb8a..5272af84b 100644
--- a/arch/x86/Makefile
+++ b/arch/x86/Makefile
@@ -228,6 +228,9 @@ ifneq ($(RETPOLINE_CFLAGS),)
 endif
 endif
 
+# Don't instrument anything here.
+GCOV_PROFILE := n
+
 archscripts: scripts_basic
 	$(Q)$(MAKE) $(build)=arch/x86/tools relocs
 
diff --git a/arch/x86/boot/Makefile b/arch/x86/boot/Makefile
index 9b5adae9c..ccea80799 100644
--- a/arch/x86/boot/Makefile
+++ b/arch/x86/boot/Makefile
@@ -18,6 +18,7 @@ OBJECT_FILES_NON_STANDARD	:= y
 # inconsistent state and crashed. We are interested mostly in syscall coverage,
 # so boot code is not interesting anyway.
 KCOV_INSTRUMENT		:= n
+GCOV_PROFILE		:= n
 
 # If you want to preset the SVGA mode, uncomment the next line and
 # set SVGA_MODE to whatever number you want.
diff --git a/arch/x86/boot/compressed/Makefile b/arch/x86/boot/compressed/Makefile
index 466f66c8a..c7a73d1ac 100644
--- a/arch/x86/boot/compressed/Makefile
+++ b/arch/x86/boot/compressed/Makefile
@@ -22,6 +22,7 @@ OBJECT_FILES_NON_STANDARD	:= y
 
 # Prevents link failures: __sanitizer_cov_trace_pc() is not linked in.
 KCOV_INSTRUMENT		:= n
+GCOV_PROFILE		:= n
 
 targets := vmlinux vmlinux.bin vmlinux.bin.gz vmlinux.bin.bz2 vmlinux.bin.lzma \
 	vmlinux.bin.xz vmlinux.bin.lzo vmlinux.bin.lz4
diff --git a/arch/x86/crypto/Makefile b/arch/x86/crypto/Makefile
index a450ad573..f5bc2a1fd 100644
--- a/arch/x86/crypto/Makefile
+++ b/arch/x86/crypto/Makefile
@@ -4,6 +4,8 @@
 #
 
 OBJECT_FILES_NON_STANDARD := y
+# Do instrument all x86 crypto stuff
+GCOV_PROFILE := y
 
 avx_supported := $(call as-instr,vpxor %xmm0$(comma)%xmm0$(comma)%xmm0,yes,no)
 avx2_supported := $(call as-instr,vpgatherdd %ymm0$(comma)(%eax$(comma)%ymm1\
diff --git a/arch/x86/entry/Makefile b/arch/x86/entry/Makefile
index 06fc70cf5..7f98eb879 100644
--- a/arch/x86/entry/Makefile
+++ b/arch/x86/entry/Makefile
@@ -2,7 +2,7 @@
 #
 # Makefile for the x86 low level entry code
 #
-
+GCOV_PROFILE := y
 OBJECT_FILES_NON_STANDARD_entry_64_compat.o := y
 
 CFLAGS_syscall_64.o		+= $(call cc-option,-Wno-override-init,)
diff --git a/arch/x86/entry/vdso/Makefile b/arch/x86/entry/vdso/Makefile
index 141d415a8..8e669eda2 100644
--- a/arch/x86/entry/vdso/Makefile
+++ b/arch/x86/entry/vdso/Makefile
@@ -10,6 +10,7 @@ OBJECT_FILES_NON_STANDARD	:= y
 
 # Prevents link failures: __sanitizer_cov_trace_pc() is not linked in.
 KCOV_INSTRUMENT		:= n
+GCOV_PROFILE		:= n
 
 VDSO64-$(CONFIG_X86_64)		:= y
 VDSOX32-$(CONFIG_X86_X32_ABI)	:= y
diff --git a/arch/x86/events/Makefile b/arch/x86/events/Makefile
index b8ccdb5c9..3dccb2213 100644
--- a/arch/x86/events/Makefile
+++ b/arch/x86/events/Makefile
@@ -1,3 +1,4 @@
+GCOV_PROFILE := y
 obj-y					+= core.o
 obj-y					+= amd/
 obj-$(CONFIG_X86_LOCAL_APIC)            += msr.o
diff --git a/arch/x86/events/intel/Makefile b/arch/x86/events/intel/Makefile
index 3468b0c1d..2974e4dc1 100644
--- a/arch/x86/events/intel/Makefile
+++ b/arch/x86/events/intel/Makefile
@@ -1,4 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
+GCOV_PROFILE := y
 obj-$(CONFIG_CPU_SUP_INTEL)		+= core.o bts.o
 obj-$(CONFIG_CPU_SUP_INTEL)		+= ds.o knc.o
 obj-$(CONFIG_CPU_SUP_INTEL)		+= lbr.o p4.o p6.o pt.o
diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index 8824d01c0..6b3410547 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -41,6 +41,7 @@ endif
 # boot, dumpstack/stacktrace, etc are either non-interesting or can lead to
 # non-deterministic coverage.
 KCOV_INSTRUMENT		:= n
+GCOV_PROFILE		:= n
 
 CFLAGS_irq.o := -I$(src)/../include/asm/trace
 
diff --git a/arch/x86/kernel/apic/Makefile b/arch/x86/kernel/apic/Makefile
index a6fcaf16c..34df719c1 100644
--- a/arch/x86/kernel/apic/Makefile
+++ b/arch/x86/kernel/apic/Makefile
@@ -6,6 +6,7 @@
 # Leads to non-deterministic coverage that is not a function of syscall inputs.
 # In particualr, smp_apic_timer_interrupt() is called in random places.
 KCOV_INSTRUMENT		:= n
+GCOV_PROFILE		:= n
 
 obj-$(CONFIG_X86_LOCAL_APIC)	+= apic.o apic_common.o apic_noop.o ipi.o vector.o
 obj-y				+= hw_nmi.o
diff --git a/arch/x86/kernel/cpu/Makefile b/arch/x86/kernel/cpu/Makefile
index 347137e80..92db5689d 100644
--- a/arch/x86/kernel/cpu/Makefile
+++ b/arch/x86/kernel/cpu/Makefile
@@ -11,7 +11,9 @@ endif
 
 # If these files are instrumented, boot hangs during the first second.
 KCOV_INSTRUMENT_common.o := n
+GCOV_PROFILE_common.o := n
 KCOV_INSTRUMENT_perf_event.o := n
+GCOV_PROFILE_perf_event.o := n
 
 # Make sure load_percpu_segment has no stackprotector
 nostackp := $(call cc-option, -fno-stack-protector)
diff --git a/arch/x86/kernel/paravirt.c b/arch/x86/kernel/paravirt.c
index 8dc69d825..1cbafa0fc 100644
--- a/arch/x86/kernel/paravirt.c
+++ b/arch/x86/kernel/paravirt.c
@@ -47,7 +47,7 @@
  * nop stub, which must not clobber anything *including the stack* to
  * avoid confusing the entry prologues.
  */
-extern void _paravirt_nop(void);
+extern void __attribute__((optimize("no-profile-values"))) _paravirt_nop(void);
 asm (".pushsection .entry.text, \"ax\"\n"
      ".global _paravirt_nop\n"
      "_paravirt_nop:\n\t"
@@ -57,12 +57,12 @@ asm (".pushsection .entry.text, \"ax\"\n"
      ".popsection");
 
 /* identity function, which can be inlined */
-u32 notrace _paravirt_ident_32(u32 x)
+u32 notrace  __attribute__((optimize("no-profile-values"))) _paravirt_ident_32(u32 x)
 {
 	return x;
 }
 
-u64 notrace _paravirt_ident_64(u64 x)
+u64 notrace  __attribute__((optimize("no-profile-values"))) _paravirt_ident_64(u64 x)
 {
 	return x;
 }
diff --git a/arch/x86/kvm/Makefile b/arch/x86/kvm/Makefile
index dc4f2fdf5..92471cf79 100644
--- a/arch/x86/kvm/Makefile
+++ b/arch/x86/kvm/Makefile
@@ -1,5 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
-
+GCOV_PROFILE := y
 ccflags-y += -Iarch/x86/kvm
 
 CFLAGS_x86.o := -I.
diff --git a/arch/x86/lib/Makefile b/arch/x86/lib/Makefile
index 25a972c61..bc4a5f815 100644
--- a/arch/x86/lib/Makefile
+++ b/arch/x86/lib/Makefile
@@ -5,6 +5,9 @@
 
 # Produces uninteresting flaky coverage.
 KCOV_INSTRUMENT_delay.o	:= n
+GCOV_PROFILE_delay.o	:= n
+# Do instrument rest of the code
+GCOV_PROFILE := y
 
 inat_tables_script = $(srctree)/arch/x86/tools/gen-insn-attr-x86.awk
 inat_tables_maps = $(srctree)/arch/x86/lib/x86-opcode-map.txt
diff --git a/arch/x86/mm/Makefile b/arch/x86/mm/Makefile
index 4b101dd6e..dee940105 100644
--- a/arch/x86/mm/Makefile
+++ b/arch/x86/mm/Makefile
@@ -2,7 +2,11 @@
 # Kernel does not boot with instrumentation of tlb.c and mem_encrypt*.c
 KCOV_INSTRUMENT_tlb.o			:= n
 KCOV_INSTRUMENT_mem_encrypt.o		:= n
-KCOV_INSTRUMENT_mem_encrypt_identity.o	:= n
+
+# Do instrument mm stuff.
+GCOV_PROFILE_tlb.o	:= n
+GCOV_PROFILE_mem_encrypt.o	:= n
+GCOV_PROFILE := y
 
 KASAN_SANITIZE_mem_encrypt.o		:= n
 KASAN_SANITIZE_mem_encrypt_identity.o	:= n
diff --git a/arch/x86/purgatory/Makefile b/arch/x86/purgatory/Makefile
index 3cf302b26..9d15ce3b7 100644
--- a/arch/x86/purgatory/Makefile
+++ b/arch/x86/purgatory/Makefile
@@ -14,6 +14,7 @@ targets += purgatory.ro
 
 KASAN_SANITIZE	:= n
 KCOV_INSTRUMENT := n
+GCOV_PROFILE := n
 
 # Default KBUILD_CFLAGS can have -pg option set when FTRACE is enabled. That
 # in turn leaves some undefined symbols like __fentry__ in purgatory and not
diff --git a/arch/x86/realmode/rm/Makefile b/arch/x86/realmode/rm/Makefile
index 4463fa72d..9b970e6da 100644
--- a/arch/x86/realmode/rm/Makefile
+++ b/arch/x86/realmode/rm/Makefile
@@ -11,6 +11,7 @@ OBJECT_FILES_NON_STANDARD	:= y
 
 # Prevents link failures: __sanitizer_cov_trace_pc() is not linked in.
 KCOV_INSTRUMENT		:= n
+GCOV_PROFILE		:= n
 
 always := realmode.bin realmode.relocs
 
diff --git a/arch/x86/um/vdso/Makefile b/arch/x86/um/vdso/Makefile
index 822ccdba9..ec1c34005 100644
--- a/arch/x86/um/vdso/Makefile
+++ b/arch/x86/um/vdso/Makefile
@@ -5,6 +5,7 @@
 
 # Prevents link failures: __sanitizer_cov_trace_pc() is not linked in.
 KCOV_INSTRUMENT                := n
+GCOV_PROFILE                := n
 
 VDSO64-y		:= y
 
diff --git a/block/Makefile b/block/Makefile
index 572b33f32..0d440b512 100644
--- a/block/Makefile
+++ b/block/Makefile
@@ -2,7 +2,7 @@
 #
 # Makefile for the kernel block layer
 #
-
+GCOV_PROFILE := y
 obj-$(CONFIG_BLOCK) := bio.o elevator.o blk-core.o blk-tag.o blk-sysfs.o \
 			blk-flush.o blk-settings.o blk-ioc.o blk-map.o \
 			blk-exec.o blk-merge.o blk-softirq.o blk-timeout.o \
diff --git a/crypto/Makefile b/crypto/Makefile
index f6a234d08..558a184ea 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -2,7 +2,7 @@
 #
 # Cryptographic API
 #
-
+GCOV_PROFILE := y
 obj-$(CONFIG_CRYPTO) += crypto.o
 crypto-y := api.o cipher.o compress.o memneq.o
 
@@ -133,6 +133,7 @@ obj-$(CONFIG_CRYPTO_ANSI_CPRNG) += ansi_cprng.o
 obj-$(CONFIG_CRYPTO_DRBG) += drbg.o
 obj-$(CONFIG_CRYPTO_JITTERENTROPY) += jitterentropy_rng.o
 CFLAGS_jitterentropy.o = -O0
+CFLAGS_GCOV_jitterentropy.o = -O0
 jitterentropy_rng-y := jitterentropy.o jitterentropy-kcapi.o
 obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
 obj-$(CONFIG_CRYPTO_GHASH) += ghash-generic.o
diff --git a/crypto/jitterentropy.c b/crypto/jitterentropy.c
index acf44b2d2..3c256adf0 100644
--- a/crypto/jitterentropy.c
+++ b/crypto/jitterentropy.c
@@ -51,9 +51,11 @@
  */
 
 #ifdef __OPTIMIZE__
- #error "The CPU Jitter random number generator must not be compiled with optimizations. See documentation. Use the compiler switch -O0 for compiling jitterentropy.c."
+ #warning "The CPU Jitter random number generator must not be compiled with optimizations. See documentation. Use the compiler switch -O0 for compiling jitterentropy.c."
+ #pragma GCC optimize "-O0"	/* Force compiler to disable optimizations */
 #endif
 
+
 typedef	unsigned long long	__u64;
 typedef	long long		__s64;
 typedef	unsigned int		__u32;
diff --git a/drivers/Makefile b/drivers/Makefile
index 578f469f7..3bd0491ef 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -5,7 +5,7 @@
 # 15 Sep 2000, Christoph Hellwig <hch@infradead.org>
 # Rewritten to use lists instead of if-statements.
 #
-
+GCOV_PROFILE := y
 obj-y				+= irqchip/
 obj-y				+= bus/
 
diff --git a/drivers/firmware/efi/libstub/Makefile b/drivers/firmware/efi/libstub/Makefile
index c51627660..536d76f58 100644
--- a/drivers/firmware/efi/libstub/Makefile
+++ b/drivers/firmware/efi/libstub/Makefile
@@ -34,6 +34,7 @@ OBJECT_FILES_NON_STANDARD	:= y
 
 # Prevents link failures: __sanitizer_cov_trace_pc() is not linked in.
 KCOV_INSTRUMENT			:= n
+GCOV_PROFILE			:= n
 
 lib-y				:= efi-stub-helper.o gop.o secureboot.o tpm.o
 
diff --git a/fs/Makefile b/fs/Makefile
index 293733f61..34d628b96 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -5,7 +5,7 @@
 # 14 Sep 2000, Christoph Hellwig <hch@infradead.org>
 # Rewritten to use lists instead of if-statements.
 # 
-
+GCOV_PROFILE := y
 obj-y :=	open.o read_write.o file_table.o super.o \
 		char_dev.o stat.o exec.o pipe.o namei.o fcntl.o \
 		ioctl.o readdir.o select.o dcache.o inode.o \
diff --git a/init/Makefile b/init/Makefile
index a3e5ce2bc..35a813392 100644
--- a/init/Makefile
+++ b/init/Makefile
@@ -5,6 +5,9 @@
 
 ccflags-y := -fno-function-sections -fno-data-sections
 
+# main.o does not produce usable profile data.
+GCOV_PROFILE_main.o := n
+
 obj-y                          := main.o version.o mounts.o
 ifneq ($(CONFIG_BLK_DEV_INITRD),y)
 obj-y                          += noinitramfs.o
diff --git a/ipc/Makefile b/ipc/Makefile
index c2558c430..f4151d0d9 100644
--- a/ipc/Makefile
+++ b/ipc/Makefile
@@ -2,7 +2,7 @@
 #
 # Makefile for the linux ipc.
 #
-
+GCOV_PROFILE := y
 obj-$(CONFIG_SYSVIPC_COMPAT) += compat.o
 obj-$(CONFIG_SYSVIPC) += util.o msgutil.o msg.o sem.o shm.o syscall.o
 obj-$(CONFIG_SYSVIPC_SYSCTL) += ipc_sysctl.o
diff --git a/kernel/Makefile b/kernel/Makefile
index e9c738432..7c54ddbdb 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -19,16 +19,20 @@ ifdef CONFIG_FUNCTION_TRACER
 # Do not trace internal ftrace files
 CFLAGS_REMOVE_irq_work.o = $(CC_FLAGS_FTRACE)
 endif
-
+GCOV_PROFILE := y
 # Prevents flicker of uninteresting __do_softirq()/__local_bh_disable_ip()
 # in coverage traces.
 KCOV_INSTRUMENT_softirq.o := n
+GCOV_PROFILE_softirq.o := n
 # These are called from save_stack_trace() on slub debug path,
 # and produce insane amounts of uninteresting coverage.
 KCOV_INSTRUMENT_module.o := n
+GCOV_PROFILE_module.o := n
 KCOV_INSTRUMENT_extable.o := n
+GCOV_PROFILE_extable.o := n
 # Don't self-instrument.
 KCOV_INSTRUMENT_kcov.o := n
+GCOV_PROFILE_kcov.o := n
 KASAN_SANITIZE_kcov.o := n
 
 # cond_syscall is currently not LTO compatible
diff --git a/kernel/gcov/Kconfig b/kernel/gcov/Kconfig
index 1e3823fa7..ac112088c 100644
--- a/kernel/gcov/Kconfig
+++ b/kernel/gcov/Kconfig
@@ -1,5 +1,16 @@
 menu "GCOV-based kernel profiling"
 
+config GCOV_PGO_ENABLE
+	bool "Enable GCC Profile guided build optimizations"
+	default n
+	---help---
+	This option enables gcov-profile based build optimizations.
+	GCC -fprofile-use=/tmp/kernelPGO option is turned on.
+	Also certain -O3 level optimiaztions are also enabled.
+	Kernel must have been first instrumented with GCOV_PROFILE_ALL and GCDA data
+	must be available at /tmp/kernelPGO. GCC GCNO data must also be available. 
+	Very experimental.
+
 config GCOV_KERNEL
 	bool "Enable gcov-based kernel profiling"
 	depends on DEBUG_FS
@@ -71,6 +82,17 @@ config GCOV_FORMAT_4_7
 	---help---
 	Select this option to use the format defined by GCC 4.7.
 
+config GCOV_FORMAT_4_9
+	bool "GCC 4.9 format"
+	---help---
+	Select this option to use the format defined by GCC 4.9.
+
+config GCOV_FORMAT_6_3
+	bool "GCC 6.3 format"
+	---help---
+	Select this option to use the format defined by GCC 6.3.
+	This version onward is comaptible with GCOV_PGO_ENABLE option.
+
 endchoice
 
 endmenu
diff --git a/kernel/gcov/Makefile b/kernel/gcov/Makefile
index ff06d64df..853622665 100644
--- a/kernel/gcov/Makefile
+++ b/kernel/gcov/Makefile
@@ -1,6 +1,44 @@
 # SPDX-License-Identifier: GPL-2.0
+GCOV_PROFILE := n
+
 ccflags-y := -DSRCTREE='"$(srctree)"' -DOBJTREE='"$(objtree)"'
 
-obj-y := base.o fs.o
-obj-$(CONFIG_GCOV_FORMAT_3_4) += gcc_3_4.o
-obj-$(CONFIG_GCOV_FORMAT_4_7) += gcc_4_7.o
+# if-lt
+# Usage VAR := $(call if-lt, $(a), $(b))
+# Returns 1 if (a < b)
+if-lt = $(shell [ $(1) -lt $(2) ] && echo 1)
+
+ifeq ($(CONFIG_GCOV_FORMAT_3_4),y)
+  cc-ver := 0304
+else ifeq ($(CONFIG_GCOV_FORMAT_4_7),y)
+  cc-ver := 0407
+else ifeq ($(CONFIG_GCOV_FORMAT_4_9),y)
+  cc-ver := 0409
+else ifeq ($(CONFIG_GCOV_FORMAT_6_3),y)
+  cc-ver := 0603
+else
+# Use cc-version if available, otherwise set 0
+#
+# scripts/Kbuild.include, which contains cc-version function, is not included
+# during make clean "make -f scripts/Makefile.clean obj=kernel/gcov"
+# Meaning cc-ver is empty causing if-lt test to fail with
+# "/bin/sh: line 0: [: -lt: unary operator expected" error mesage.
+# This has no affect on the clean phase, but the error message could be
+# confusing/annoying. So this dummy workaround sets cc-ver to zero if cc-version
+# is not available. We can probably move if-lt to Kbuild.include, so it's also
+# not defined during clean or to include Kbuild.include in
+# scripts/Makefile.clean. But the following workaround seems least invasive.
+  cc-ver := $(if $(call cc-version),$(call cc-version),0)
+endif
+
+obj-$(CONFIG_GCOV_KERNEL) := base.o fs.o
+
+ifeq ($(call if-lt, $(cc-ver), 0407),1)
+  obj-$(CONFIG_GCOV_KERNEL) += gcc_3_4.o
+else ifeq ($(call if-lt, $(cc-ver), 0409),1)
+  obj-$(CONFIG_GCOV_KERNEL) += gcc_4_7.o
+else ifeq ($(call if-lt, $(cc-ver), 0603),1)
+  obj-$(CONFIG_GCOV_KERNEL) += gcc_4_9.o
+else
+  obj-$(CONFIG_GCOV_KERNEL) += gcc_4_9.o
+endif
diff --git a/kernel/gcov/base.c b/kernel/gcov/base.c
index 9c7c8d5c1..194bff87f 100644
--- a/kernel/gcov/base.c
+++ b/kernel/gcov/base.c
@@ -63,6 +63,12 @@ void __gcov_flush(void)
 }
 EXPORT_SYMBOL(__gcov_flush);
 
+void __gcov_exit(void)
+{
+	/* Unused. */
+}
+EXPORT_SYMBOL(__gcov_exit);
+
 void __gcov_merge_add(gcov_type *counters, unsigned int n_counters)
 {
 	/* Unused. */
@@ -93,17 +99,258 @@ void __gcov_merge_time_profile(gcov_type *counters, unsigned int n_counters)
 }
 EXPORT_SYMBOL(__gcov_merge_time_profile);
 
-void __gcov_merge_icall_topn(gcov_type *counters, unsigned int n_counters)
+/*
+ * Inline try-lock must be used to keep kgcov state consistent.
+ * GCC will inject calls to functions below from all kernel code.
+ * We still need atomic ops for modifying the counter data,
+ * this try-lock ensures proper multi-RMW ordering.
+ */
+static atomic_t __gcov_lock_mtx = { 0 };
+
+static inline int __gcov_try_lock(void)
 {
-	/* Unused. */
+	return !(atomic_cmpxchg(&__gcov_lock_mtx, 0, 1));
 }
-EXPORT_SYMBOL(__gcov_merge_icall_topn);
 
-void __gcov_exit(void)
+static inline void __gcov_unlock(void)
 {
-	/* Unused. */
+	atomic_set(&__gcov_lock_mtx, 0);
 }
-EXPORT_SYMBOL(__gcov_exit);
+
+static inline void __gcov_one_value_profiler_body(gcov_type *counters,
+						  gcov_arg value)
+{
+	gcov_arg val, tst;
+	while(1) {
+		val = GCOV_COUNTER_READ(counters+1);
+		tst = GCOV_COUNTER_READ(counters);
+		if( tst == value) {
+			GCOV_COUNTER_INC(counters+1);
+		} else if (val == 0) {
+			if(GCOV_COUNTER_CMPXCHG(counters+1, val, 1) == val) {
+				GCOV_COUNTER_SET(counters, value);
+			} else
+				continue; /* retry */
+		} else {
+			GCOV_COUNTER_DEC(counters+1);
+		}
+		GCOV_COUNTER_INC(counters+2);
+		return;
+	}
+}
+
+void __gcov_indirect_call_profiler(gcov_type *counter, gcov_arg value,
+				   void *cur_func, void *callee_func)
+{
+	if(__gcov_try_lock()) {
+	if (cur_func == callee_func)
+		__gcov_one_value_profiler_body(counter, value);
+	__gcov_unlock(); }
+}
+EXPORT_SYMBOL(__gcov_indirect_call_profiler);
+
+void *__gcov_indirect_call_callee = NULL;
+EXPORT_SYMBOL(__gcov_indirect_call_callee);
+gcov_type *__gcov_indirect_call_counters = NULL;
+EXPORT_SYMBOL(__gcov_indirect_call_counters);
+
+void __gcov_indirect_call_profiler_v2(gcov_arg value, void *cur_func)
+{
+	if(__gcov_try_lock()) {
+		if (cur_func == __gcov_indirect_call_callee)
+			__gcov_one_value_profiler_body(__gcov_indirect_call_counters,
+							value);
+	__gcov_unlock(); }
+}
+EXPORT_SYMBOL(__gcov_indirect_call_profiler_v2);
+
+gcov_arg __gcov_time_profiler_counter = { 0 };
+EXPORT_SYMBOL(__gcov_time_profiler_counter);
+
+void __gcov_ior_profiler(gcov_type *counters, gcov_arg value)
+{
+	if(__gcov_try_lock()) {
+	GCOV_COUNTER_BITOR(counters, value);
+	__gcov_unlock(); }
+}
+EXPORT_SYMBOL(__gcov_ior_profiler);
+
+/* atomic variant export */
+void __gcov_ior_profiler_atomic(gcov_type *counters, gcov_arg value)
+{
+	__gcov_ior_profiler(counters, value);
+}
+EXPORT_SYMBOL(__gcov_ior_profiler_atomic);
+
+void __gcov_average_profiler(gcov_type *counters, gcov_arg value)
+{
+	if(__gcov_try_lock()) {
+	GCOV_COUNTER_ADD(counters, value);
+	GCOV_COUNTER_INC(counters+1);
+	__gcov_unlock(); }
+}
+EXPORT_SYMBOL(__gcov_average_profiler);
+
+/* atomic variant export */
+void __gcov_average_profiler_atomic(gcov_type *counters, gcov_arg value)
+{
+	__gcov_average_profiler(counters, value);
+}
+EXPORT_SYMBOL(__gcov_average_profiler_atomic);
+
+void __gcov_one_value_profiler(gcov_type *counters, gcov_arg value)
+{
+	if(__gcov_try_lock()) {
+	__gcov_one_value_profiler_body(counters, value);
+	__gcov_unlock(); }
+}
+EXPORT_SYMBOL(__gcov_one_value_profiler);
+
+/* atomic variant export */
+void __gcov_one_value_profiler_atomic(gcov_type *counters, gcov_arg value)
+{
+	if(__gcov_try_lock()) {
+	__gcov_one_value_profiler_body(counters, value);
+	__gcov_unlock(); }
+}
+EXPORT_SYMBOL(__gcov_one_value_profiler_atomic);
+
+void __gcov_interval_profiler(gcov_type *counters, gcov_arg value,
+			      int start, unsigned steps)
+{
+	long long delta = value - start;
+	if(__gcov_try_lock()) {
+	if (delta < 0)
+		GCOV_COUNTER_INC(counters + steps + 1);
+	else if (delta >= steps)
+		GCOV_COUNTER_INC(counters + steps);
+	else
+		GCOV_COUNTER_INC(counters + delta);
+	__gcov_unlock(); }
+}
+EXPORT_SYMBOL(__gcov_interval_profiler);
+
+/* atomic variant export */
+void __gcov_interval_profiler_atomic(gcov_type *counters, gcov_arg value,
+			      int start, unsigned steps)
+{
+	__gcov_interval_profiler(counters, value, start, steps);
+}
+EXPORT_SYMBOL(__gcov_interval_profiler_atomic);
+
+void __gcov_pow2_profiler(gcov_type *counters, gcov_arg value)
+{
+	if(__gcov_try_lock()) {
+	if (value & (value - 1))
+		GCOV_COUNTER_INC(counters);
+	else
+		GCOV_COUNTER_INC(counters+1);
+	__gcov_unlock(); }
+}
+EXPORT_SYMBOL(__gcov_pow2_profiler);
+
+/* atomic variant export */
+void __gcov_pow2_profiler_atomic(gcov_type *counters, gcov_arg value)
+{
+	__gcov_pow2_profiler(counters, value);
+}
+EXPORT_SYMBOL(__gcov_pow2_profiler_atomic);
+
+/* gcc does not use this profiler by default yet */
+static inline void __gcov_topn_value_profiler_body(gcov_type * counters, gcov_arg value)
+{
+	unsigned int i, j, found = 0, have_zero_count = 0;
+	gcov_type * entry;
+	gcov_type * lfu_entry = counters+1;
+	gcov_type * value_array = counters+1;
+	gcov_type * num_eviction = counters;
+	const unsigned int topn_val = GCOV_ICALL_TOPN_VAL;
+	gcov_type tmp_cnts[GCOV_ICALL_TOPN_VAL];
+	gcov_type * p, minv;
+
+	/* There are 2*topn_val values tracked, each value takes two slots in the
+	  counter array.  */
+	for(i = 0; i < (topn_val << 2); i += 2) {
+		entry = value_array+i;
+		if(GCOV_COUNTER_READ(entry) == value) {
+			GCOV_COUNTER_INC(entry+1);
+			found = 1;
+			break;
+		} else if(GCOV_COUNTER_READ(entry+1) == 0) {
+			lfu_entry = entry;
+			have_zero_count = 1;
+		} else if(GCOV_COUNTER_READ(entry+1) < GCOV_COUNTER_READ(lfu_entry+1)) {
+			lfu_entry = entry;
+		}
+	}
+
+	if(found) {
+		return;
+	}
+
+	/* lfu_entry is either an empty entry or an entry
+	 * with lowest count, which will be evicted.  */
+	GCOV_COUNTER_SET(lfu_entry, value);
+	GCOV_COUNTER_SET(lfu_entry+1, 1);
+
+	#define GCOV_ICALL_COUNTER_CLEAR_THRESHOLD 3000
+
+	/* Too many evictions -- time to clear bottom entries to
+	  avoid hot values bumping each other out.  */
+	if(!have_zero_count
+		&&  GCOV_COUNTER_FETCH_ADD(num_eviction,1)+1 >= GCOV_ICALL_COUNTER_CLEAR_THRESHOLD) {
+
+		GCOV_COUNTER_SET(num_eviction, 0);
+
+		for(i = 0; i < topn_val; i++) {
+			GCOV_COUNTER_SET(tmp_cnts+i, 0);
+		}
+
+		/* Find the largest topn_val values from the group of
+		 * 2*topn_val values and put them into tmp_cnts.  */
+		for(i = 0; i < 2 * topn_val; i += 2) {
+			p = 0;
+			for(j = 0; j < topn_val; j++) {
+				if(!p || GCOV_COUNTER_READ(tmp_cnts+j) < GCOV_COUNTER_READ(p)) {
+					p = tmp_cnts+j;
+				}
+			}
+			if(GCOV_COUNTER_READ(value_array+i + 1) > GCOV_COUNTER_READ(p)) {
+				GCOV_COUNTER_SET(p, GCOV_COUNTER_READ(value_array+i + 1));
+			}
+		}
+
+		minv = tmp_cnts[0];
+		for(j = 1; j < topn_val; j++) {
+			if(GCOV_COUNTER_READ(tmp_cnts+j) < GCOV_COUNTER_READ(&minv)) {
+				minv = tmp_cnts[j];
+			}
+		}
+		/* Zero out low value entries.  */
+		for(i = 0; i < 2 * topn_val; i += 2) {
+			if(GCOV_COUNTER_READ(value_array+i + 1) < GCOV_COUNTER_READ(&minv)) {
+				GCOV_COUNTER_SET(value_array+i, 0);
+				GCOV_COUNTER_SET(value_array+i+1, 0);
+			}
+		}
+	}
+}
+
+gcov_type *__gcov_indirect_call_topn_counters;
+EXPORT_SYMBOL(__gcov_indirect_call_topn_counters);
+void *__gcov_indirect_call_topn_callee;
+EXPORT_SYMBOL(__gcov_indirect_call_topn_callee);
+
+void __gcov_indirect_call_topn_profiler(gcov_arg value, void* cur_func)
+{
+	if(__gcov_try_lock()) {
+	void *callee_func = __gcov_indirect_call_topn_callee;
+	if (cur_func == callee_func) {
+		__gcov_topn_value_profiler_body (__gcov_indirect_call_topn_counters, value);
+	}
+	__gcov_unlock(); }
+}
+EXPORT_SYMBOL(__gcov_indirect_call_topn_profiler);
 
 /**
  * gcov_enable_events - enable event reporting through gcov_event()
@@ -130,6 +377,11 @@ void gcov_enable_events(void)
 }
 
 #ifdef CONFIG_MODULES
+static inline int within(void *addr, void *start, unsigned long size)
+{
+	return ((addr >= start) && (addr < start + size));
+}
+
 /* Update list and generate events when modules are unloaded. */
 static int gcov_module_notifier(struct notifier_block *nb, unsigned long event,
 				void *data)
diff --git a/kernel/gcov/gcc_4_7.c b/kernel/gcov/gcc_4_7.c
index ca5e5c0ef..e02554f03 100644
--- a/kernel/gcov/gcc_4_7.c
+++ b/kernel/gcov/gcc_4_7.c
@@ -19,12 +19,10 @@
 #include <linux/vmalloc.h>
 #include "gcov.h"
 
-#if (__GNUC__ >= 7)
-#define GCOV_COUNTERS			9
-#elif (__GNUC__ > 5) || (__GNUC__ == 5 && __GNUC_MINOR__ >= 1)
-#define GCOV_COUNTERS			10
+#if __GNUC__ >= 5 && __GNUC_MINOR__ >= 1
+#define GCOV_COUNTERS			8
 #elif __GNUC__ == 4 && __GNUC_MINOR__ >= 9
-#define GCOV_COUNTERS			9
+#define GCOV_COUNTERS			8
 #else
 #define GCOV_COUNTERS			8
 #endif
@@ -213,6 +211,85 @@ int gcov_info_is_compatible(struct gcov_info *info1, struct gcov_info *info2)
 	return (info1->stamp == info2->stamp);
 }
 
+typedef void (*gcov_merge_fn)(struct gcov_ctr_info *dst,
+			      const struct gcov_ctr_info *src);
+
+static void gcov_merge_add(struct gcov_ctr_info *dst,
+			   const struct gcov_ctr_info *src)
+{
+	unsigned int i;
+	for (i = 0; i < src->num; ++i)
+		dst->values[i] += src->values[i];
+}
+
+static void gcov_merge_single(struct gcov_ctr_info *dst,
+			      const struct gcov_ctr_info *src)
+{
+	unsigned int i;
+	gcov_type value, counter, all;
+	if (src->num % 3)
+		return;
+	for (i = 0; i < src->num; ) {
+		value = src->values[i++];
+		counter = src->values[i++];
+		all = src->values[i++];
+
+		if (dst->values[0] == value) {
+			dst->values[1] += counter;
+		} else if (counter > dst->values[1]) {
+			dst->values[0] = value;
+			dst->values[1] = counter - dst->values[1];
+		} else {
+			dst->values[1] -= counter;
+		}
+		dst->values[2] += all;
+	}
+}
+
+static void gcov_merge_delta(struct gcov_ctr_info *dst,
+			     const struct gcov_ctr_info *src)
+{
+	unsigned int i;
+	gcov_type value, counter, all;
+	if (src->num % 4)
+		return;
+	for (i = 0; i < src->num; ) {
+		i++;
+		value = src->values[i++];
+		counter = src->values[i++];
+		all = src->values[i++];
+
+		if (dst->values[1] == value) {
+			dst->values[2] += counter;
+		} else if (counter > dst->values[2]) {
+			dst->values[1] = value;
+			dst->values[2] = counter - dst->values[2];
+		} else {
+			dst->values[2] -= counter;
+		}
+		dst->values[3] += all;
+	}
+}
+
+static void gcov_merge_ior(struct gcov_ctr_info *dst,
+			   const struct gcov_ctr_info *src)
+{
+	unsigned int i;
+	for (i = 0; i < src->num; ++i)
+		dst->values[i] |= src->values[i];
+}
+
+static const gcov_merge_fn gcov_merge[GCOV_COUNTERS] = {
+	&gcov_merge_add,
+	&gcov_merge_add,
+	&gcov_merge_add,
+	&gcov_merge_single,
+	&gcov_merge_delta,
+	&gcov_merge_single,
+	&gcov_merge_add,
+	&gcov_merge_ior
+};
+
 /**
  * gcov_info_add - add up profiling data
  * @dest: profiling data set to which data is added
@@ -236,9 +313,7 @@ void gcov_info_add(struct gcov_info *dst, struct gcov_info *src)
 			if (!counter_active(src, ct_idx))
 				continue;
 
-			for (val_idx = 0; val_idx < sci_ptr->num; val_idx++)
-				dci_ptr->values[val_idx] +=
-					sci_ptr->values[val_idx];
+			gcov_merge[ct_idx](dci_ptr, sci_ptr);
 
 			dci_ptr++;
 			sci_ptr++;
@@ -300,7 +375,7 @@ struct gcov_info *gcov_info_dup(struct gcov_info *info)
 
 			dci_ptr->values = vmalloc(cv_size);
 
-			if (!dci_ptr->values)
+			if (cv_size && !dci_ptr->values)
 				goto err_free;
 
 			dci_ptr->num = sci_ptr->num;
diff --git a/kernel/gcov/gcc_4_9.c b/kernel/gcov/gcc_4_9.c
new file mode 100644
index 000000000..8ad3bb9c6
--- /dev/null
+++ b/kernel/gcov/gcc_4_9.c
@@ -0,0 +1,764 @@
+/*
+ *  This code provides functions to handle gcc's profiling data format
+ *  introduced with gcc 4.9+
+ *
+ *  This file is based heavily on gcc_4_7.c file.
+ *
+ *  For a better understanding, refer to gcc source:
+ *  gcc/gcov-io.h
+ *  gcc/tree-profile.c
+ *  libgcc/libgcov*
+ *
+ *  Uses gcc-internal data definitions.
+ */
+
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/seq_file.h>
+#include <linux/vmalloc.h>
+#include "gcov.h"
+
+#if __GNUC__ >= 6
+#define GCOV_COUNTERS			9
+#elif __GNUC__ == 5 && __GNUC_MINOR__ >= 1
+#define GCOV_COUNTERS			9
+#elif __GNUC__ == 4 && __GNUC_MINOR__ >= 9
+#define GCOV_COUNTERS			9
+#else
+#define GCOV_COUNTERS			8
+#endif
+
+#define GCOV_TAG_FUNCTION_LENGTH	3
+
+static struct gcov_info *gcov_info_head;
+
+/**
+ * struct gcov_ctr_info - information about counters for a single function
+ * @num: number of counter values for this type
+ * @values: array of counter values for this type
+ *
+ * This data is generated by gcc during compilation and doesn't change
+ * at run-time with the exception of the values array.
+ */
+struct gcov_ctr_info {
+	unsigned int num;
+	gcov_type *values;
+};
+
+/**
+ * struct gcov_fn_info - profiling meta data per function
+ * @key: comdat key
+ * @ident: unique ident of function
+ * @lineno_checksum: function lineo_checksum
+ * @cfg_checksum: function cfg checksum
+ * @ctrs: instrumented counters
+ *
+ * This data is generated by gcc during compilation and doesn't change
+ * at run-time.
+ *
+ * Information about a single function.  This uses the trailing array
+ * idiom. The number of counters is determined from the merge pointer
+ * array in gcov_info.  The key is used to detect which of a set of
+ * comdat functions was selected -- it points to the gcov_info object
+ * of the object file containing the selected comdat function.
+ */
+struct gcov_fn_info {
+	const struct gcov_info *key;
+	unsigned int ident;
+	unsigned int lineno_checksum;
+	unsigned int cfg_checksum;
+	struct gcov_ctr_info ctrs[1];
+};
+
+/**
+ * struct gcov_info - profiling data per object file
+ * @version: gcov version magic indicating the gcc version used for compilation
+ * @next: list head for a singly-linked list
+ * @stamp: uniquifying time stamp
+ * @filename: name of the associated gcov data file
+ * @merge: merge functions (null for unused counter type)
+ * @n_functions: number of instrumented functions
+ * @functions: pointer to pointers to function information
+ *
+ * This data is generated by gcc during compilation and doesn't change
+ * at run-time with the exception of the next pointer.
+ */
+struct gcov_info {
+	unsigned int version;
+	struct gcov_info *next;
+	unsigned int stamp;
+	const char *filename;
+	void (*merge[GCOV_COUNTERS])(gcov_type *, unsigned int);
+	unsigned int n_functions;
+	struct gcov_fn_info **functions;
+};
+
+/**
+ * gcov_info_filename - return info filename
+ * @info: profiling data set
+ */
+const char *gcov_info_filename(struct gcov_info *info)
+{
+	return info->filename;
+}
+
+/**
+ * gcov_info_version - return info version
+ * @info: profiling data set
+ */
+unsigned int gcov_info_version(struct gcov_info *info)
+{
+	return info->version;
+}
+
+/**
+ * gcov_info_next - return next profiling data set
+ * @info: profiling data set
+ *
+ * Returns next gcov_info following @info or first gcov_info in the chain if
+ * @info is %NULL.
+ */
+struct gcov_info *gcov_info_next(struct gcov_info *info)
+{
+	if (!info)
+		return gcov_info_head;
+
+	return info->next;
+}
+
+/**
+ * gcov_info_link - link/add profiling data set to the list
+ * @info: profiling data set
+ */
+void gcov_info_link(struct gcov_info *info)
+{
+	info->next = gcov_info_head;
+	gcov_info_head = info;
+}
+
+/**
+ * gcov_info_unlink - unlink/remove profiling data set from the list
+ * @prev: previous profiling data set
+ * @info: profiling data set
+ */
+void gcov_info_unlink(struct gcov_info *prev, struct gcov_info *info)
+{
+	if (prev)
+		prev->next = info->next;
+	else
+		gcov_info_head = info->next;
+}
+
+/* Symbolic links to be created for each profiling data file. */
+const struct gcov_link gcov_link[] = {
+	{ OBJ_TREE, "gcno" },	/* Link to .gcno file in $(objtree). */
+	{ 0, NULL},
+};
+
+/*
+ * Determine whether a counter is active. Doesn't change at run-time.
+ */
+static int counter_active(struct gcov_info *info, unsigned int type)
+{
+	return info->merge[type] ? 1 : 0;
+}
+
+/* Determine number of active counters. Based on gcc magic. */
+static unsigned int num_counter_active(struct gcov_info *info)
+{
+	unsigned int i;
+	unsigned int result = 0;
+
+	for (i = 0; i < GCOV_COUNTERS; i++) {
+		if (counter_active(info, i))
+			result++;
+	}
+	return result;
+}
+
+/**
+ * gcov_info_reset - reset profiling data to zero
+ * @info: profiling data set
+ */
+void gcov_info_reset(struct gcov_info *info)
+{
+	struct gcov_ctr_info *ci_ptr;
+	unsigned int fi_idx;
+	unsigned int ct_idx;
+
+	for (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {
+		ci_ptr = info->functions[fi_idx]->ctrs;
+
+		for (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {
+			if (!counter_active(info, ct_idx))
+				continue;
+
+			memset(ci_ptr->values, 0,
+					sizeof(gcov_type) * ci_ptr->num);
+			ci_ptr++;
+		}
+	}
+}
+
+/**
+ * gcov_info_is_compatible - check if profiling data can be added
+ * @info1: first profiling data set
+ * @info2: second profiling data set
+ *
+ * Returns non-zero if profiling data can be added, zero otherwise.
+ */
+int gcov_info_is_compatible(struct gcov_info *info1, struct gcov_info *info2)
+{
+	return (info1->stamp == info2->stamp);
+}
+
+typedef void (*gcov_merge_fn)(struct gcov_ctr_info *dst,
+			      const struct gcov_ctr_info *src);
+
+static void gcov_merge_add(struct gcov_ctr_info *dst,
+			   const struct gcov_ctr_info *src)
+{
+	unsigned int i;
+	for (i = 0; i < src->num; ++i)
+		GCOV_COUNTER_ADD(dst->values+i, GCOV_COUNTER_READ(src->values+i));
+}
+
+static void gcov_merge_single(struct gcov_ctr_info *dst,
+			      const struct gcov_ctr_info *src)
+{
+	unsigned int i;
+	gcov_arg value, counter, all;
+	if (src->num % 3)
+		return;
+	for (i = 0; i < src->num; ) {
+		value = GCOV_COUNTER_READ(src->values + i++);
+		counter = GCOV_COUNTER_READ(src->values + i++);
+		all = GCOV_COUNTER_READ(src->values + i++);
+
+		if (GCOV_COUNTER_READ(dst->values) == value) {
+			GCOV_COUNTER_ADD(dst->values+1, counter);
+		} else if (counter > GCOV_COUNTER_READ(dst->values+1)) {
+			GCOV_COUNTER_SET(dst->values, value);
+			GCOV_COUNTER_SET(dst->values+1, counter - GCOV_COUNTER_READ(dst->values+1));
+		} else {
+			GCOV_COUNTER_SUB(dst->values+1, counter);
+		}
+		GCOV_COUNTER_ADD(dst->values+2, all);
+	}
+}
+
+static void gcov_merge_delta(struct gcov_ctr_info *dst,
+			     const struct gcov_ctr_info *src)
+{
+	unsigned int i;
+	gcov_arg value, counter, all;
+	if (src->num % 4)
+		return;
+	for (i = 0; i < src->num; ) {
+		i++;
+		value = GCOV_COUNTER_READ(src->values + i++);
+		counter = GCOV_COUNTER_READ(src->values + i++);
+		all = GCOV_COUNTER_READ(src->values + i++);
+
+		if (GCOV_COUNTER_READ(dst->values+1) == value) {
+			GCOV_COUNTER_ADD(dst->values+2, counter);
+		} else if (counter > GCOV_COUNTER_READ(dst->values+2)) {
+			GCOV_COUNTER_SET(dst->values+1, value);
+			GCOV_COUNTER_SET(dst->values+2, counter - GCOV_COUNTER_READ(dst->values+2));
+		} else {
+			GCOV_COUNTER_SUB(dst->values+2, counter);
+		}
+		GCOV_COUNTER_ADD(dst->values+3, all);
+	}
+}
+
+static void gcov_merge_ior(struct gcov_ctr_info *dst,
+			   const struct gcov_ctr_info *src)
+{
+	unsigned int i;
+	for (i = 0; i < src->num; ++i)
+		GCOV_COUNTER_BITOR(dst->values+i, GCOV_COUNTER_READ(src->values+i));
+}
+
+static void gcov_merge_time_profile(struct gcov_ctr_info *dst,
+				    const struct gcov_ctr_info *src)
+{
+	unsigned int i;
+	gcov_arg srcval, dstval;
+	for (i = 0; i < src->num; ++i) {
+		srcval = GCOV_COUNTER_READ(src->values+i);
+		dstval = GCOV_COUNTER_READ(dst->values+i);
+		if (srcval && (!dstval || srcval < dstval)) {
+			GCOV_COUNTER_SET(dst->values+i, srcval);
+		}
+	}
+}
+
+/* topn value profiler */
+static inline void gcov_sort_n_vals (gcov_type *value_array, int n)
+{
+	int j, k;
+	gcov_arg cur_ent[2];
+	for (j = 2; j < n; j += 2)
+	{
+		cur_ent[0] = GCOV_COUNTER_READ(value_array+j);
+		cur_ent[1] = GCOV_COUNTER_READ(value_array+j+1);
+		k = j - 2;
+		while (k >= 0 && GCOV_COUNTER_READ(value_array+k+1) < cur_ent[1])
+		{
+			GCOV_COUNTER_SET(value_array+k + 2, GCOV_COUNTER_READ(value_array+k));
+			GCOV_COUNTER_SET(value_array+k + 3, GCOV_COUNTER_READ(value_array+k+1));
+			k -= 2;
+		}
+		GCOV_COUNTER_SET(value_array+k + 2, cur_ent[0]);
+		GCOV_COUNTER_SET(value_array+k + 3, cur_ent[1]);
+	}
+}
+
+/* topn value profiler
+ * The func is heavily modified from gcc 6.1 libgcov-merge.c:
+ * __gcov_merge_icall_topn(gcov_type *counters, unsigned n_counters)
+ */
+static void gcov_merge_icall_topn(struct gcov_ctr_info *dst,
+                            const struct gcov_ctr_info *src)
+{
+	unsigned int i, j, k, m;
+	const unsigned int tmp_size = 2 * (GCOV_ICALL_TOPN_NCOUNTS - 1);
+	gcov_type tmp_array[tmp_size];
+	gcov_type * value_array;
+	gcov_type global_id, call_count;
+	// ignore
+	if(src->num % GCOV_ICALL_TOPN_NCOUNTS)
+		return;
+
+	/* cpy src to dst. */
+	for(i = 0; i < src->num; ++i)
+		dst->values[i] = src->values[i];
+	dst->num = src->num;
+
+	for(i = 0; i < src->num; i += GCOV_ICALL_TOPN_NCOUNTS)
+	{
+		value_array = dst->values + i + 1; /* &counters[i + 1]*/
+
+		for(j = 0; j < tmp_size; j++) {
+			GCOV_COUNTER_SET(tmp_array+j, 0);
+		}
+
+		for(j = 0; j < GCOV_ICALL_TOPN_NCOUNTS - 1; j += 2) {
+			tmp_array[j] = dst->values[j];
+			tmp_array[j + 1] = dst->values [j + 1];
+		}
+
+		/* Skip the number_of_eviction entry.  */
+		i++; /* get_counter*/
+		for(k = 0; k < GCOV_ICALL_TOPN_NCOUNTS - 1; k += 2) {
+			int found = 0;
+			global_id = dst->values[i++];   /* get_counter*/
+			call_count = dst->values[i++];  /* get_counter*/
+			for(m = 0; m < j; m += 2) {
+				if(GCOV_COUNTER_READ(tmp_array+m) == GCOV_COUNTER_READ(&global_id)) {
+					found = 1;
+					GCOV_COUNTER_ADD(tmp_array+m + 1, GCOV_COUNTER_READ(&call_count));
+					break;
+				}
+			}
+			if(!found) {
+				tmp_array[j] = global_id;
+				tmp_array[j + 1] = call_count;
+				j += 2;
+			}
+		}
+		/* Now sort the temp array */
+		gcov_sort_n_vals(tmp_array, j);
+
+		/* Now copy back the top half of the temp array */
+		for(k = 0; k < GCOV_ICALL_TOPN_NCOUNTS - 1; k += 2) {
+			dst->values[k] = tmp_array[k];
+			dst->values[k + 1] = tmp_array[k + 1];
+		}
+	}
+}
+/* as of gcc 7.1 has following counters defined:
+DEF_GCOV_COUNTER(GCOV_COUNTER_ARCS, "arcs", _add)
+DEF_GCOV_COUNTER(GCOV_COUNTER_V_INTERVAL, "interval", _add)
+DEF_GCOV_COUNTER(GCOV_COUNTER_V_POW2, "pow2", _add)
+DEF_GCOV_COUNTER(GCOV_COUNTER_V_SINGLE, "single", _single)
+DEF_GCOV_COUNTER(GCOV_COUNTER_V_INDIR, "indirect_call", _single)
+DEF_GCOV_COUNTER(GCOV_COUNTER_AVERAGE, "average", _add)
+DEF_GCOV_COUNTER(GCOV_COUNTER_IOR, "ior", _ior)
+DEF_GCOV_COUNTER(GCOV_TIME_PROFILER, "time_profiler", _time_profile)
+DEF_GCOV_COUNTER(GCOV_COUNTER_ICALL_TOPNV, "indirect_call_topn", _icall_topn)
+The last one - indirect_call_topn, is not yet utilized by gcc.
+*/
+static const gcov_merge_fn gcov_merge[GCOV_COUNTERS] = {
+	&gcov_merge_add,
+	&gcov_merge_add,
+	&gcov_merge_add,
+	&gcov_merge_single,
+	&gcov_merge_single,
+	&gcov_merge_add,
+	&gcov_merge_ior,
+	&gcov_merge_time_profile,
+	&gcov_merge_icall_topn
+};
+
+/**
+ * gcov_info_add - add up profiling data
+ * @dest: profiling data set to which data is added
+ * @source: profiling data set which is added
+ *
+ * Adds profiling counts of @source to @dest.
+ */
+void gcov_info_add(struct gcov_info *dst, struct gcov_info *src)
+{
+	struct gcov_ctr_info *dci_ptr;
+	struct gcov_ctr_info *sci_ptr;
+	unsigned int fi_idx;
+	unsigned int ct_idx;
+
+	for (fi_idx = 0; fi_idx < src->n_functions; fi_idx++) {
+		dci_ptr = dst->functions[fi_idx]->ctrs;
+		sci_ptr = src->functions[fi_idx]->ctrs;
+
+		for (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {
+			if (!counter_active(src, ct_idx))
+				continue;
+
+			gcov_merge[ct_idx](dci_ptr, sci_ptr);
+
+			dci_ptr++;
+			sci_ptr++;
+		}
+	}
+}
+
+/**
+ * gcov_info_dup - duplicate profiling data set
+ * @info: profiling data set to duplicate
+ *
+ * Return newly allocated duplicate on success, %NULL on error.
+ */
+struct gcov_info *gcov_info_dup(struct gcov_info *info)
+{
+	struct gcov_info *dup;
+	struct gcov_ctr_info *dci_ptr; /* dst counter info */
+	struct gcov_ctr_info *sci_ptr; /* src counter info */
+	unsigned int active;
+	unsigned int fi_idx; /* function info idx */
+	unsigned int ct_idx; /* counter type idx */
+	size_t fi_size; /* function info size */
+	size_t cv_size; /* counter values size */
+	size_t cv_num;
+	dup = kmemdup(info, sizeof(*dup), GFP_KERNEL);
+	if (!dup)
+		return NULL;
+
+	dup->next = NULL;
+	dup->filename = NULL;
+	dup->functions = NULL;
+
+	dup->filename = kstrdup(info->filename, GFP_KERNEL);
+	if (!dup->filename)
+		goto err_free;
+
+	dup->functions = kcalloc(info->n_functions,
+				 sizeof(struct gcov_fn_info *), GFP_KERNEL);
+	if (!dup->functions)
+		goto err_free;
+
+	active = num_counter_active(info);
+	fi_size = sizeof(struct gcov_fn_info);
+	fi_size += sizeof(struct gcov_ctr_info) * active;
+
+	for (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {
+		dup->functions[fi_idx] = kzalloc(fi_size, GFP_KERNEL);
+		if (!dup->functions[fi_idx])
+			goto err_free;
+
+		*(dup->functions[fi_idx]) = *(info->functions[fi_idx]);
+
+		sci_ptr = info->functions[fi_idx]->ctrs;
+		dci_ptr = dup->functions[fi_idx]->ctrs;
+
+		for (ct_idx = 0; ct_idx < active; ct_idx++) {
+			cv_num = sci_ptr->num;
+			cv_size = sizeof(gcov_type) * cv_num;
+			/* skip zero size requests - vmalloc doesn't like them */
+			if(cv_num) {
+				dci_ptr->values = vmalloc(cv_size);
+
+				if (cv_num && !dci_ptr->values)
+					goto err_free;
+
+				memcpy(dci_ptr->values, sci_ptr->values, cv_size);
+				dci_ptr->num = cv_num;
+			} else {
+				dci_ptr->values = NULL;
+				dci_ptr->num = 0;
+			}
+			sci_ptr++;
+			dci_ptr++;
+		}
+	}
+
+	return dup;
+err_free:
+	pr_warn("Failed to reserve %ld values for gcov!", cv_num);
+	gcov_info_free(dup);
+	return NULL;
+}
+
+/**
+ * gcov_info_free - release memory for profiling data set duplicate
+ * @info: profiling data set duplicate to free
+ */
+void gcov_info_free(struct gcov_info *info)
+{
+	unsigned int active;
+	unsigned int fi_idx;
+	unsigned int ct_idx;
+	struct gcov_ctr_info *ci_ptr;
+
+	if (!info->functions)
+		goto free_info;
+
+	active = num_counter_active(info);
+
+	for (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {
+		if (!info->functions[fi_idx])
+			continue;
+
+		ci_ptr = info->functions[fi_idx]->ctrs;
+
+		for (ct_idx = 0; ct_idx < active; ct_idx++, ci_ptr++)
+			vfree(ci_ptr->values);
+
+		kfree(info->functions[fi_idx]);
+	}
+
+free_info:
+	kfree(info->functions);
+	kfree(info->filename);
+	kfree(info);
+}
+
+#define ITER_STRIDE	PAGE_SIZE
+
+/**
+ * struct gcov_iterator - specifies current file position in logical records
+ * @info: associated profiling data
+ * @buffer: buffer containing file data
+ * @size: size of buffer
+ * @pos: current position in file
+ */
+struct gcov_iterator {
+	struct gcov_info *info;
+	void *buffer;
+	size_t size;
+	loff_t pos;
+};
+
+/**
+ * store_gcov_u32 - store 32 bit number in gcov format to buffer
+ * @buffer: target buffer or NULL
+ * @off: offset into the buffer
+ * @v: value to be stored
+ *
+ * Number format defined by gcc: numbers are recorded in the 32 bit
+ * unsigned binary form of the endianness of the machine generating the
+ * file. Returns the number of bytes stored. If @buffer is %NULL, doesn't
+ * store anything.
+ */
+static size_t store_gcov_u32(void *buffer, size_t off, u32 v)
+{
+	u32 *data;
+
+	if (buffer) {
+		data = buffer + off;
+		*data = v;
+	}
+
+	return sizeof(*data);
+}
+
+/**
+ * store_gcov_u64 - store 64 bit number in gcov format to buffer
+ * @buffer: target buffer or NULL
+ * @off: offset into the buffer
+ * @v: value to be stored
+ *
+ * Number format defined by gcc: numbers are recorded in the 32 bit
+ * unsigned binary form of the endianness of the machine generating the
+ * file. 64 bit numbers are stored as two 32 bit numbers, the low part
+ * first. Returns the number of bytes stored. If @buffer is %NULL, doesn't store
+ * anything.
+ */
+static size_t store_gcov_u64(void *buffer, size_t off, u64 v)
+{
+	u32 *data;
+
+	if (buffer) {
+		data = buffer + off;
+
+		data[0] = (v & 0xffffffffUL);
+		data[1] = (v >> 32);
+	}
+
+	return sizeof(*data) * 2;
+}
+
+/**
+ * convert_to_gcda - convert profiling data set to gcda file format
+ * @buffer: the buffer to store file data or %NULL if no data should be stored
+ * @info: profiling data set to be converted
+ *
+ * Returns the number of bytes that were/would have been stored into the buffer.
+ */
+static size_t convert_to_gcda(char *buffer, struct gcov_info *info)
+{
+	struct gcov_fn_info *fi_ptr;
+	struct gcov_ctr_info *ci_ptr;
+	unsigned int fi_idx;
+	unsigned int ct_idx;
+	unsigned int cv_idx;
+	size_t pos = 0;
+
+	/* File header. */
+	pos += store_gcov_u32(buffer, pos, GCOV_DATA_MAGIC);
+	/* fixme: info->version has bogus old version value */
+	pos += store_gcov_u32(buffer, pos, info->version);
+	pos += store_gcov_u32(buffer, pos, info->stamp);
+
+	for (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {
+		fi_ptr = info->functions[fi_idx];
+
+		/* Function record. */
+		pos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION);
+		pos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION_LENGTH);
+		pos += store_gcov_u32(buffer, pos, fi_ptr->ident);
+		pos += store_gcov_u32(buffer, pos, fi_ptr->lineno_checksum);
+		pos += store_gcov_u32(buffer, pos, fi_ptr->cfg_checksum);
+
+		ci_ptr = fi_ptr->ctrs;
+
+		for (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {
+			if (!counter_active(info, ct_idx))
+				continue;
+
+			/* Counter record. */
+			pos += store_gcov_u32(buffer, pos,
+					      GCOV_TAG_FOR_COUNTER(ct_idx));
+			pos += store_gcov_u32(buffer, pos, ci_ptr->num * 2);
+
+			for (cv_idx = 0; cv_idx < ci_ptr->num; cv_idx++) {
+				pos += store_gcov_u64(buffer, pos,
+						      GCOV_COUNTER_READ(ci_ptr->values+cv_idx));
+			}
+
+			ci_ptr++;
+		}
+	}
+
+	return pos;
+}
+
+/**
+ * gcov_iter_new - allocate and initialize profiling data iterator
+ * @info: profiling data set to be iterated
+ *
+ * Return file iterator on success, %NULL otherwise.
+ */
+struct gcov_iterator *gcov_iter_new(struct gcov_info *info)
+{
+	struct gcov_iterator *iter;
+	iter = kzalloc(sizeof(struct gcov_iterator), GFP_KERNEL);
+	if (!iter)
+		goto err_free;
+
+	iter->info = info;
+	/* Dry-run to get the actual buffer size. */
+	iter->size = convert_to_gcda(NULL, info);
+	/* print notice that we are really doing something. */
+	pr_info("Emiting %ldk GCDA for %s", iter->size / 1024, info ? info->filename : "");
+	iter->buffer = vmalloc(iter->size);
+	if (!iter->buffer)
+		goto err_free;
+
+	convert_to_gcda(iter->buffer, info);
+
+	return iter;
+
+err_free:
+	kfree(iter);
+	return NULL;
+}
+
+
+/**
+ * gcov_iter_get_info - return profiling data set for given file iterator
+ * @iter: file iterator
+ */
+void gcov_iter_free(struct gcov_iterator *iter)
+{
+	vfree(iter->buffer);
+	kfree(iter);
+}
+
+/**
+ * gcov_iter_get_info - return profiling data set for given file iterator
+ * @iter: file iterator
+ */
+struct gcov_info *gcov_iter_get_info(struct gcov_iterator *iter)
+{
+	return iter->info;
+}
+
+/**
+ * gcov_iter_start - reset file iterator to starting position
+ * @iter: file iterator
+ */
+void gcov_iter_start(struct gcov_iterator *iter)
+{
+	iter->pos = 0;
+}
+
+/**
+ * gcov_iter_next - advance file iterator to next logical record
+ * @iter: file iterator
+ *
+ * Return zero if new position is valid, non-zero if iterator has reached end.
+ */
+int gcov_iter_next(struct gcov_iterator *iter)
+{
+	if (iter->pos < iter->size)
+		iter->pos += ITER_STRIDE;
+
+	if (iter->pos >= iter->size)
+		return -EINVAL;
+
+	return 0;
+}
+
+/**
+ * gcov_iter_write - write data for current pos to seq_file
+ * @iter: file iterator
+ * @seq: seq_file handle
+ *
+ * Return zero on success, non-zero otherwise.
+ */
+int gcov_iter_write(struct gcov_iterator *iter, struct seq_file *seq)
+{
+	size_t len;
+
+	if (iter->pos >= iter->size)
+		return -EINVAL;
+
+	len = ITER_STRIDE;
+	if (iter->pos + len > iter->size)
+		len = iter->size - iter->pos;
+
+	seq_write(seq, iter->buffer + iter->pos, len);
+
+	return 0;
+}
diff --git a/kernel/gcov/gcov.h b/kernel/gcov/gcov.h
index de118ad4a..d8dd19598 100644
--- a/kernel/gcov/gcov.h
+++ b/kernel/gcov/gcov.h
@@ -16,24 +16,61 @@
 #define GCOV_H GCOV_H
 
 #include <linux/types.h>
+#include <asm/atomic.h>
 
 /*
  * Profiling data types used for gcc 3.4 and above - these are defined by
  * gcc and need to be kept as close to the original definition as possible to
  * remain compatible.
  */
-#define GCOV_DATA_MAGIC		((unsigned int) 0x67636461)
+#define GCOV_DATA_MAGIC		((unsigned int) 0x67636461) /* "GCDA" */
 #define GCOV_TAG_FUNCTION	((unsigned int) 0x01000000)
 #define GCOV_TAG_COUNTER_BASE	((unsigned int) 0x01a10000)
 #define GCOV_TAG_FOR_COUNTER(count)					\
 	(GCOV_TAG_COUNTER_BASE + ((unsigned int) (count) << 17))
 
+/* The number of hottest callees to be tracked.  */
+#define GCOV_ICALL_TOPN_VAL  2
+
+/* The number of counter entries per icall callsite.  */
+#define GCOV_ICALL_TOPN_NCOUNTS (1 + GCOV_ICALL_TOPN_VAL * 4)
+
+/*
+ * To make kgcov data stable enough for GCC FDO consumption,
+ * kgcov profiling code must be thread-safe.
+ * This means using atomic operations to when operating on the counters.
+ * These macros wrap all operations done on the raw profile counters
+ * maintained by gcc.
+ */
 #if BITS_PER_LONG >= 64
-typedef long gcov_type;
+typedef atomic64_t gcov_type;
+typedef long long gcov_arg;
+#define GCOV_COUNTER_READ(X) atomic64_read((X))
+#define GCOV_COUNTER_SET(X, A) atomic64_set((X), (A))
+#define GCOV_COUNTER_INC(X) atomic64_inc((X))
+#define GCOV_COUNTER_DEC(X) atomic64_dec((X))
+#define GCOV_COUNTER_ADD(X, A) atomic64_add((A), (X))
+#define GCOV_COUNTER_SUB(X, A) atomic64_sub((A), (X))
+#define GCOV_COUNTER_FETCH_ADD(X, A) atomic64_fetch_add((A), (X))
+#define GCOV_COUNTER_FETCH_SUB(X, A) atomic64_fetch_sub((A), (X))
+#define GCOV_COUNTER_BITOR(X, A) atomic64_or((A), (X))
+#define GCOV_COUNTER_CMPXCHG(X, B, A) atomic64_cmpxchg((X), (B), (A))
 #else
-typedef long long gcov_type;
+typedef atomic_t gcov_type;
+typedef long gcov_arg;
+#define GCOV_COUNTER_READ(X) ((gcov_type) atomic_read((atomic_t*)&(X)))
+#define GCOV_COUNTER_SET(X, A) atomic_set((atomic_t*)&(X), (A))
+#define GCOV_COUNTER_INC(X) atomic_inc((atomic_t*)&(X))
+#define GCOV_COUNTER_DEC(X) atomic_dec((atomic_t*)&(X))
+#define GCOV_COUNTER_ADD(X, A) atomic_add((A), (atomic_t*)&(X))
+#define GCOV_COUNTER_SUB(X, A) atomic_sub((A), (atomic_t*)&(X))
+#define GCOV_COUNTER_FETCH_ADD(X, A) atomic_fetch_add((A), (atomic_t*)&(X))
+#define GCOV_COUNTER_FETCH_SUB(X, A) atomic_fetch_sub((A), (atomic_t*)&(X))
+#define GCOV_COUNTER_BITOR(X, A) atomic_or((A), (atomic_t*)&(X))
+#define GCOV_COUNTER_CMPXCHG(X, B, A) atomic_cmpxchg((X), (B), (A))
 #endif
 
+
 /* Opaque gcov_info. The gcov structures can change as for example in gcc 4.7 so
  * we cannot use full definition here and they need to be placed in gcc specific
  * implementation of gcov. This also means no direct access to the members in
diff --git a/lib/Makefile b/lib/Makefile
index 423876446..ba6c0a776 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -11,11 +11,17 @@ endif
 # These files are disabled because they produce lots of non-interesting and/or
 # flaky coverage that is not a function of syscall inputs. For example,
 # rbtree can be global and individual rotations don't correlate with inputs.
+GCOV_PROFILE := y
 KCOV_INSTRUMENT_string.o := n
+GCOV_PROFILE_string.o := n
 KCOV_INSTRUMENT_rbtree.o := n
+GCOV_PROFILE_rbtree.o := n
 KCOV_INSTRUMENT_list_debug.o := n
+GCOV_PROFILE_list_debug.o := n
 KCOV_INSTRUMENT_debugobjects.o := n
+GCOV_PROFILE_debugobjects.o := n
 KCOV_INSTRUMENT_dynamic_debug.o := n
+GCOV_PROFILE_dynamic_debug.o := n
 
 lib-y := ctype.o string.o vsprintf.o cmdline.o \
 	 rbtree.o radix-tree.o timerqueue.o\
@@ -199,6 +205,7 @@ obj-$(CONFIG_IRQ_POLL) += irq_poll.o
 obj-$(CONFIG_STACKDEPOT) += stackdepot.o
 KASAN_SANITIZE_stackdepot.o := n
 KCOV_INSTRUMENT_stackdepot.o := n
+GCOV_PROFILE_stackdepot.o := n
 
 libfdt_files = fdt.o fdt_ro.o fdt_wip.o fdt_rw.o fdt_sw.o fdt_strerror.o \
 	       fdt_empty_tree.o
diff --git a/mm/Makefile b/mm/Makefile
index 26ef77a38..0aaa50547 100644
--- a/mm/Makefile
+++ b/mm/Makefile
@@ -20,6 +20,7 @@ KCOV_INSTRUMENT_kmemleak.o := n
 KCOV_INSTRUMENT_memcontrol.o := n
 KCOV_INSTRUMENT_mmzone.o := n
 KCOV_INSTRUMENT_vmstat.o := n
+GCOV_PROFILE := y
 
 mmu-y			:= nommu.o
 mmu-$(CONFIG_MMU)	:= gup.o highmem.o memory.o mincore.o \
diff --git a/mm/kasan/Makefile b/mm/kasan/Makefile
index 3289db38b..860095f72 100644
--- a/mm/kasan/Makefile
+++ b/mm/kasan/Makefile
@@ -2,6 +2,7 @@
 KASAN_SANITIZE := n
 UBSAN_SANITIZE_kasan.o := n
 KCOV_INSTRUMENT := n
+GCOV_PROFILE := n
 
 CFLAGS_REMOVE_kasan.o = -pg
 # Function splitter causes unnecessary splits in __asan_load1/__asan_store1
diff --git a/net/Makefile b/net/Makefile
index bdaf53925..d8649343b 100644
--- a/net/Makefile
+++ b/net/Makefile
@@ -5,7 +5,7 @@
 # 2 Sep 2000, Christoph Hellwig <hch@infradead.org>
 # Rewritten to use lists instead of if-statements.
 #
-
+GCOV_PROFILE := y
 obj-$(CONFIG_NET)		:= socket.o core/
 
 tmp-$(CONFIG_COMPAT) 		:= compat.o
diff --git a/scripts/gcov/buildGCOVKernel b/scripts/gcov/buildGCOVKernel
new file mode 100755
index 000000000..aaf3fa20a
--- /dev/null
+++ b/scripts/gcov/buildGCOVKernel
@@ -0,0 +1,38 @@
+#!/bin/bash
+# This script builds an GCOV instumented kernel.
+echo 'This GCOV/PGO patchset has been modified for GCC/GCOV 9.2.0.'
+echo 'Setup instrumented kernel build env'
+# We need to mount the kernel source in /tmp root to make the profile data system agnostic
+# without it the generated profile data is useless.
+DIR=$PWD
+mkdir -p /tmp/kernelsrc >/dev/null 2>&1
+[ -f /tmp/kernelsrc/scripts/gcov/buildGCOVKernel ] || sudo mount --rbind $PWD /tmp/kernelsrc
+[ -f /tmp/kernelsrc/scripts/gcov/buildGCOVKernel ] || { echo "Failed to link $PWD to /tmp/kernelsrc"; exit 1; }
+
+# Clean-up the mount on exit.
+cleanup() {
+    cd $DIR
+    sudo umount /tmp/kernelsrc
+}
+trap cleanup SIGINT SIGHUP SIGTERM
+
+cd /tmp/kernelsrc
+
+echo 'Enabling kernel profiling in config..'
+make silentoldconfig
+./scripts/config -e CONFIG_GCOV_KERNEL -e CONFIG_GCOV_PROFILE_ALL -e CONFIG_GCOV_FORMAT_6_3 --disable CONFIG_GCOV_PGO_ENABLE
+
+echo 'Building Instrumented Kernel.'
+# Build the kernel with kgcc
+# It is not possible to build instrumented/pgo kernel with distro gcc configuration:
+#   gcc produces invalid code producing 'TLS' references to the gcov variables but kernel-code does not have TLS.
+# Also we are thinking the kernel as one monolith 'program' we are instrumenting.
+make $@  V=2 CC=gcc AR=gcc-ar NM=gcc-nm -j$(cat /proc/cpuinfo | grep processor | wc -l)
+if [ $? -eq 0 ]; then
+    echo 'Kernel build okay!'
+    ./scripts/gcov/gathergcno.sh gcnoprofile.tar.gz
+    exit 0
+else
+    echo 'Kernel build failed. Stop.'
+    exit 2;
+fi
diff --git a/scripts/gcov/calcsum-4.9.cpp b/scripts/gcov/calcsum-4.9.cpp
new file mode 100644
index 000000000..23471bd92
--- /dev/null
+++ b/scripts/gcov/calcsum-4.9.cpp
@@ -0,0 +1,258 @@
+// KPGO Project
+
+#include <stdio.h>
+#include <string>
+#include <vector>
+#include <assert.h>
+
+using namespace std;
+
+static unsigned histogram_index (long long value)
+{
+	unsigned long long v = (unsigned long long)value;
+	unsigned r = 0;
+	unsigned prev2bits = 0;
+	if (v > 0)
+		r = 63 - __builtin_clzll (v);
+	if (r < 2)
+		return (unsigned)value;
+	assert (r < 64);
+	prev2bits = (v >> (r - 2)) & 0x3;
+	return (r - 1) * 4 + prev2bits;
+}
+
+static int read_file(const char *filename, vector<char> &out)
+{
+	FILE *fp = fopen(filename, "rb");
+	if (!fp)
+	{
+		fprintf(stderr, "[!] Fail to read: %s\n", filename);
+		return 1;
+	}
+	char buf[4096];
+	size_t sz;
+	while ((sz = fread(buf, 1, 4096, fp)))
+		out.insert(out.end(), buf, buf + sz);
+	fclose(fp);
+	return 0;
+}
+
+static void split_lines(const vector<char> &in, vector<string> &out)
+{
+	size_t pos = 0;
+	for (size_t i = 0; i < in.size(); ++i)
+	{
+		if (in[i] != '\r' && in[i] != '\n')
+			continue;
+		out.push_back(string(in.begin() + pos, in.begin() + i));
+		if (in[i] == '\r' && i + 1 < in.size() && in[i + 1] == '\n')
+			i++;
+		pos = i + 1;
+	}
+	if (pos < in.size())
+		out.push_back(string(in.begin() + pos, in.end()));
+}
+
+static unsigned num;
+static long long sum_all, max_val;
+struct bucket
+{
+	unsigned num;
+	long long min, sum;
+} histogram[256];
+
+static void histogram_insert(long long value)
+{
+	unsigned i = histogram_index(value);
+	histogram[i].num++;
+	histogram[i].sum += value;
+	if (value < histogram[i].min)
+		histogram[i].min = value;
+}
+
+#define GCOV_DATA_MAGIC		  0x67636461u
+#define GCOV_TAG_FUNCTION		0x01000000u
+#define GCOV_TAG_COUNTER_BASE	0x01a10000u
+#define GCOV_TAG_PROGRAM_SUMMARY 0xa3000000u
+
+int process(const unsigned *v, int n)
+{
+	int state = 1;
+	unsigned count;
+	for (int i = 0; i < n; ++i)
+	{
+		unsigned val = v[i];
+		switch (state)
+		{
+			case 1:
+				if (val != GCOV_DATA_MAGIC)
+				{
+					fprintf(stderr, "[!] GCOV_DATA_MAGIC mismatch: 0x%x\n", val);
+					return 1;
+				}
+				i += 2;
+				state = 2;
+				break;
+			case 2:
+				if (i == n - 1 && val)
+				{
+					fprintf(stderr, "[!] Single last tag: 0x%x\n", val);
+					return 2;
+				}
+				if (val == GCOV_TAG_FUNCTION)
+					i += 1 + v[i + 1];
+				else if (val == GCOV_TAG_COUNTER_BASE)
+				{
+					if (v[i + 1] % 2)
+					{
+						fprintf(stderr, "[!] Invalid length: %d\n", v[i + 1]);
+						return 3;
+					}
+					count = v[i + 1] / 2;
+					num += count;
+					if (count)
+						state = 3;
+					i++;
+				}
+				else if (val)
+				{
+					if (!(val & 0xffff) && ((val - GCOV_TAG_COUNTER_BASE) >> 17) < 9)
+						i += 1 + v[i + 1];
+					else
+					{
+						fprintf(stderr, "[!] Unknown tag: 0x%x\n", val);
+						return 4;
+					}
+				}
+				break;
+			case 3:
+				long long ctr = v[++i];
+				ctr = (ctr << 32) + val;
+				histogram_insert(ctr);
+				sum_all += ctr;
+				if (ctr > max_val)
+					max_val = ctr;
+				if (--count == 0)
+					state = 2;
+				break;
+		}
+		if (i >= n)
+		{
+			fprintf(stderr, "[!] Overflow\n");
+			return 5;
+		}
+	}
+	if (state == 3)
+	{
+		fprintf(stderr, "[!] Overflow\n");
+		return 6;
+	}
+	return 0;
+}
+
+unsigned mask[8], hcount = 0;
+
+int write_file(const vector<char> in, const char *filename)
+{
+	if (in.size() < 12)
+	{
+		fprintf(stderr, "[!] Not enough to write\n");
+		return 1;
+	}
+	FILE *fp = fopen(filename, "wb");
+	if (!fp)
+	{
+		fprintf(stderr, "[!] Fail to write: %s\n", filename);
+		return 2;
+	}
+	// set the gcov version in format "702*" aka gcc 7.2.*
+	// the magic value is simply "*306" string casted to uint32_t
+	// or picked from the gcc error message.
+	// I have not yet figured out where kgcov registers the
+	// GCC version or how to change it automatically per build.
+	/* The version for gcov 9.2.0 seems to be 1094267434.
+	                  (the previous value was 1094201898) */
+	unsigned int gcov_version = 1094267434;
+	fwrite(in.data(), 1, 4, fp);
+	fwrite(&gcov_version, 1, 4, fp);
+	fwrite(in.data()+8, 1, 4, fp);
+
+	unsigned tmp[11] = {
+		GCOV_TAG_PROGRAM_SUMMARY,
+		17 + hcount * 5,
+		0,
+		num,
+		1,
+		(unsigned)sum_all,
+		(unsigned)(sum_all >> 32),
+		(unsigned)max_val,
+		(unsigned)(max_val >> 32),
+		(unsigned)max_val,
+		(unsigned)(max_val >> 32)
+	};
+	fwrite(tmp, 1, 44, fp);
+	fwrite(mask, 1, 32, fp);
+	for (int i = 0; i < 256; ++i)
+	{
+		if (histogram[i].num <= 0)
+			continue;
+		unsigned tmp2[5] = {
+			histogram[i].num,
+			(unsigned)(histogram[i].min),
+			(unsigned)(histogram[i].min >> 32),
+			(unsigned)(histogram[i].sum),
+			(unsigned)(histogram[i].sum >> 32)
+		};
+		fwrite(tmp2, 1, 20, fp);
+	}
+	fwrite(in.data() + 12, 1, in.size() - 12, fp);
+	fclose(fp);
+	return 0;
+}
+
+int main(int argc, char **argv)
+{
+	vector<char> content;
+	if (argc != 2 || read_file(argv[1], content))
+	{
+		fprintf(stderr, "USAGE:\n  %s <Input File List>\n", argv[0]);
+		return 1;
+	}
+	for (int i = 0; i < 256; ++i)
+		histogram[i].min = 0x7fffffffffffffffll;
+	vector<string> lines;
+	split_lines(content, lines);
+	vector<vector<char> > v(lines.size());
+	for (size_t i = 0; i < lines.size(); ++i)
+	{
+		const char *filename = lines[i].c_str();
+		if (read_file(filename, v[i]))
+			return 2;
+		if (v[i].size() % 4)
+		{
+			fprintf(stderr, "[!] File size mismatch: %s\n", filename);
+			return 3;
+		}
+		fprintf(stderr, "[.] Processing %s\n", filename);
+		if (process((const unsigned *)v[i].data(), v[i].size() / 4))
+			return 4;
+	}
+	fprintf(stderr, "[.] num: %d\n", num);
+	fprintf(stderr, "[.] sum_all: %lld\n", sum_all);
+	fprintf(stderr, "[.] max_val: %lld\n", max_val);
+	for (int i = 0; i < 256; ++i)
+	{
+		if (histogram[i].num <= 0)
+			continue;
+		hcount++;
+		mask[i / 32] |= 1 << (i % 32);
+		fprintf(stderr, "[.] histogram(%03d): num=%d, min=%lld, sum=%lld\n", i, histogram[i].num, histogram[i].min, histogram[i].sum);
+	}
+	for (size_t i = 0; i < lines.size(); ++i)
+	{
+		if (write_file(v[i], lines[i].c_str()))
+			return 5;
+	}
+	fprintf(stderr, "[.] Files processed: %d\n", (int)lines.size());
+	return 0;
+}
diff --git a/scripts/gcov/gather.sh b/scripts/gcov/gather.sh
new file mode 100755
index 000000000..12272f64a
--- /dev/null
+++ b/scripts/gcov/gather.sh
@@ -0,0 +1,25 @@
+#!/bin/bash -e
+
+DEST=$1
+GCDA=/sys/kernel/debug/gcov
+
+if [ ! -d "$GCDA" ] ; then
+  echo "mount -t debugfs none /sys/kernel/debug"
+  exit 1
+fi
+
+if [ -z "$DEST" ] ; then
+  echo "Usage: $0 <output.tar.gz>" >&2
+  exit 1
+fi
+
+TEMPDIR=$(mktemp -d)
+echo Collecting data..
+find $GCDA -type d -exec mkdir -p $TEMPDIR/\{\} \;
+find $GCDA -name '*.gcda' -exec sh -c 'cat < $0 > '$TEMPDIR'/$0' {} \;
+#find $GCDA -name '*.gcno' -exec sh -c 'cp -d $0 '$TEMPDIR'/$0' {} \;
+tar czf $DEST -C $TEMPDIR .
+rm -rf $TEMPDIR
+
+echo "$DEST successfully created, copy to build system and unpack with:"
+echo "  tar xfz $DEST"
diff --git a/scripts/gcov/gathergcno.sh b/scripts/gcov/gathergcno.sh
new file mode 100755
index 000000000..b407f4a1b
--- /dev/null
+++ b/scripts/gcov/gathergcno.sh
@@ -0,0 +1,18 @@
+#!/bin/bash -e
+# Store all gcno files generated by the compiler.
+# .gcno files are needed by lcov tool to view the profile data.
+# both .gcno and .gcda files *must* be from exactly same build or
+# lcov won't work.
+DEST=$1
+
+TEMPDIR=$(mktemp -d)
+
+echo "Collecting GCNO compiler data.."
+
+find . \( -path ./.git -o -path ./Documentation -o -path ./samples -o -path ./scripts -o -path ./tools \) -prune -o -type d -exec mkdir -p $TEMPDIR/\{\} \;
+find . \( -path ./.git -o -path ./Documentation -o -path ./samples -o -path ./scripts -o -path ./tools \) -prune -o -name '*.gcno' -exec sh -c 'cp -d $0 '$TEMPDIR'/$0' {} \;
+tar czf $DEST -C $TEMPDIR .
+rm -rf $TEMPDIR
+
+echo "$DEST successfully created, unpack with:"
+echo "  tar xfz $DEST"
diff --git a/scripts/gcov/genPGOKernel b/scripts/gcov/genPGOKernel
new file mode 100755
index 000000000..b21919816
--- /dev/null
+++ b/scripts/gcov/genPGOKernel
@@ -0,0 +1,116 @@
+
+#!/bin/bash -e
+# Process kernel gcov profile data
+# and mangle it for consumption by PGO build
+# the kernel is built after this.
+
+echo 'Initializing kernel PGO optimization..'
+DIR=$PWD
+mkdir -p /tmp/kernelsrc
+[ -f /tmp/kernelsrc/scripts/gcov/genPGOKernel ] || sudo mount --rbind $DIR /tmp/kernelsrc
+cd /tmp/kernelsrc
+
+die() {
+    echo $1;
+    exit 1;
+}
+
+# clean-up any mountpoint(s) on error.
+cleanup() {
+    cd $DIR
+    sudo umount /tmp/kernelsrc
+}
+trap cleanup SIGINT SIGHUP SIGTERM
+
+echo 'Configuring profile data..'
+CHECKPROF=/tmp/kernelPGOdump/sys/kernel/debug/gcov/tmp/kernelsrc
+if [ ! -f $CHECKPROF/mm/.tmp_mmap.gcda ]; then
+    echo 'Checking profile data..'
+    if [ ! -f profile.tar.gz ]; then
+        echo "Missing profile.tar.gz GCDA data!"
+        die "It must be created with `gather.sh profile.tar.gz` on the instrumented system"
+    fi
+
+    if [ ! -f gcnoprofile.tar.gz ]; then
+        echo "Missing gcnoprofile.tar.gz GCNO data!"
+        die "It should be created by `gathergcno.sh gcnoprofile.tar.gz` after successful buildGCOVKernel run"
+    fi
+
+    rm -fr /tmp/kernelPGOdump
+    mkdir /tmp/kernelPGOdump
+
+    tar xzf profile.tar.gz -C /tmp/kernelPGOdump
+    tar xzf gcnoprofile.tar.gz -C .
+    if [ ! -f $CHECKPROF/mm/mmap.gcda  ]; then
+        die 'No Kernel profiling data available. Stop.'
+    fi
+    echo 'Discaring arch/x86/ profile data. (it has a lot of uninstrumentible code)'
+    rm -rf $CHECKPROF/arch/x86
+    echo 'Postprocesing profile data with calcsum..'
+    find /tmp/kernelPGOdump -name '*.gcda' > list.txt
+    ./scripts/gcov/calcsum list.txt >/dev/null
+    rm -f list.txt
+
+    # run gcov-tool rewrite -s 1.0
+    # this is effectively a no-op but ensures the profile data is valid.
+    # the tool appeared in gcc 6.1 and seems to be able fixup
+    # any missing info in the gcda files.
+    # To improve the profile data consistency multiple data sets should
+    # be merged and then scaled.
+    echo 'Postprocesing profile data with gcov-tool..'
+    gcov-tool rewrite -s 1.0 -o /tmp/kernelPGOdump/ /tmp/kernelPGOdump/
+
+    echo 'Adjusting profile data file names..'
+    find /tmp/kernelPGOdump/* -name '*.gcda' -print0 | xargs -0 -n1 -P0 ./scripts/gcov/rename.sh
+
+else
+    echo 'NOTE: Using alredy configured profile data.'
+fi
+
+echo 'Binding profile data dir..'
+mkdir -p /tmp/kernelPGO/
+if [ ! -f '/tmp/kernelPGO/mm/.tmp_mmap.gcda' ]; then
+    sudo mount --rbind /tmp/kernelPGOdump/sys/kernel/debug/gcov/tmp/kernelsrc /tmp/kernelPGO
+fi
+
+cleanup2() {
+    cleanup;
+    sudo umount /tmp/kernelPGO
+}
+trap cleanup2 SIGINT SIGHUP SIGTERM
+
+# abort if no profile data.
+if [ ! -f '/tmp/kernelPGO/mm/.tmp_mmap.gcda' ]; then
+    die 'Final Profile data missing. Stop.'
+fi
+
+echo 'Disabling kernel profiling in config and building in PGO mode.'
+
+# Note: GCOV_PGO_ENABLE Kconfig option must be enabled to use
+# the profile data in build. This option was necessary as Kbuild must
+# be able to override any default PGO enabled build options.
+./scripts/config --disable CONFIG_GCOV_KERNEL --disable CONFIG_GCOV_PROFILE_ALL --enable CONFIG_GCOV_PGO_ENABLE
+
+# remove old build logs
+{
+mv -f build.log build.log.old || true
+mv -f optimize.log optimize.log.old || true
+} >/dev/null 2>&1
+
+echo 'Building final Profile optimized kernel.'
+echo 'See optimize.log for applied optimizations so far.'
+echo 'See build.log for normal KBuild log so far.'
+taskset -pc 0-7 $$ >/dev/null
+{
+make $@ V=2 CC=gcc AR=gcc-ar NM=gcc-nm -j$(cat /proc/cpuinfo | grep processor | wc -l) KCFLAGS="-fgraphite-identity -floop-nest-optimize -fopt-info-optall=optimize.log";
+if [ $? -eq 0 ]; then
+    echo 'Profile Optimized Kernel build okay!'
+    exit 0
+else
+    echo 'Kernel build failed. Stop.'
+    exit 2;
+fi
+} >build.log 2>&1
+
+echo "Build of profile optimized kernel is done."
+cd $DIR
diff --git a/scripts/gcov/mergegcov.sh b/scripts/gcov/mergegcov.sh
new file mode 100755
index 000000000..69502d70c
--- /dev/null
+++ b/scripts/gcov/mergegcov.sh
@@ -0,0 +1,49 @@
+#!/bin/bash
+
+# Batch Merge multiple GCOV profile data sets
+# all profileXX.tar.gz are extracted to /tmp/kernelPGOdumpXX dirs.
+# Counters are then accumulated into /tmp/kernelPGOdump dir
+
+if [[ ! -f ./scripts/gcov/calcsum  ]]; then
+    echo "Compiling calcsum-4.9 for post processing the profile data.."
+    gcc -O2 ./scripts/gcov/calcsum-4.9.cpp -o ./scripts/gcov/calcsum -lstdc++
+fi
+
+NUM=1
+for gcdapkg in $@; do
+	mkdir -p /tmp/kernelPGOdump${NUM}
+	tar xzf ${gcdapkg} -C /tmp/kernelPGOdump${NUM}
+    if [[ ! -f /tmp/kernelPGOdump${NUM}/sys/kernel/debug/gcov/tmp/kernelsrc/mm/mmap.gcda  ]]; then
+        echo 'No Kernel profiling data available. Stop.'
+        exit 1
+    fi
+    echo "Postprocesing GCOV data set ${NUM} with calcsum.."
+    find /tmp/kernelPGOdump${NUM} -name '*.gcda' > list.txt
+    ./scripts/gcov/calcsum list.txt >/dev/null 2>&1
+    rm -f list.txt
+    
+    echo "Postprocesing GCOV data set ${NUM} with gcov-tool.."
+    gcov-tool rewrite -s 1.0 -o /tmp/kernelPGOdump${NUM} /tmp/kernelPGOdump${NUM}
+    (( NUM += 1 ))
+done
+
+# rename first data set as final data set dir
+mv /tmp/kernelPGOdump1 /tmp/kernelPGOdump
+
+MC=2
+while [[ $MC -lt $NUM ]]; do
+    # Merge rest into first data set.
+    echo "Merging GCOV data set ${MC}.."
+    gcov-tool merge -w 1.0,1.0 -o /tmp/kernelPGOdump /tmp/kernelPGOdump /tmp/kernelPGOdump${MC}
+    (( MC += 1 ))
+done
+
+if [[ ! -f /tmp/kernelPGOdump/sys/kernel/debug/gcov/tmp/kernelsrc/mm/mmap.gcda  ]]; then
+	echo 'Profile Data Merge failed..'
+	exit 1
+fi
+echo 'Discaring arch/x86/ profile data...'
+#rm -rf /tmp/kernelPGOdump/sys/kernel/debug/gcov/tmp/kernelPGO/arch/x86
+echo 'Adjusting profile data file names..'
+find /tmp/kernelPGOdump/ -name '*.gcda' -print0 | xargs -0 -n1 -P0 ./scripts/gcov/rename.sh
+    
diff --git a/scripts/gcov/processGCOVMakefiles b/scripts/gcov/processGCOVMakefiles
new file mode 100755
index 000000000..92a4a4eb2
--- /dev/null
+++ b/scripts/gcov/processGCOVMakefiles
@@ -0,0 +1,3 @@
+#!/bin/sh
+# big pipeline to add 'GCOV_PROFILE := n' where equalent 'KCOV_INSTRUMENT' is set.
+find . -path ./.git -prune  -o -name 'Makefile' -print0 | xargs -0 sed -i 's#KCOV_INSTRUMENT\(.*\)#KCOV_INSTRUMENT\1\nGCOV_PROFILE\1#g'
diff --git a/scripts/gcov/rename.sh b/scripts/gcov/rename.sh
new file mode 100755
index 000000000..08976de7f
--- /dev/null
+++ b/scripts/gcov/rename.sh
@@ -0,0 +1,4 @@
+#!/bin/sh
+RN=$(echo "$1" | sed -ne 's#\(.*\)\/\(.*\)#\1/.tmp_\2#p')
+cp "$1" "${RN}"
+rm "$1"
diff --git a/sound/Makefile b/sound/Makefile
index 797ecdcd3..27276d1fc 100644
--- a/sound/Makefile
+++ b/sound/Makefile
@@ -1,7 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 # Makefile for the Linux sound card driver
 #
-
+GCOV_PROFILE := y
 obj-$(CONFIG_SOUND) += soundcore.o
 obj-$(CONFIG_DMASOUND) += oss/dmasound/
 obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ sh/ synth/ usb/ \
diff --git a/virt/Makefile b/virt/Makefile
index be783472a..771505393 100644
--- a/virt/Makefile
+++ b/virt/Makefile
@@ -1 +1,2 @@
+GCOV_PROFILE := y
 obj-y	+= lib/
-- 
2.23.0

