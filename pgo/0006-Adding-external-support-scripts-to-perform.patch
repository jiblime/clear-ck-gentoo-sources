From b1505c45163b0228144c5f9baa2e76496bcccbed Mon Sep 17 00:00:00 2001
From: Jarmo Tiitto <jarmo.tiitto@gmail.com>
Date: Wed, 31 May 2017 09:54:17 +0300
Subject: [PATCH 06/21] Adding external support scripts to perform the full two
 staged PGO kernel build. 	* buildGCOVKernel warps the invocation of make
 to setup system independent profile data and source location directories. It
 then proceeds to build GCOV instrumented kernel. 	* genPGOKernel does
 similiar but it extracts the gcov profile data and post processes it. Finally
 kconfig is updated to disable instrumentation and enable profile data
 consumption.

---
 buildGCOVKernel      |  35 ++++++
 calcsum-4.9.cpp      | 256 +++++++++++++++++++++++++++++++++++++++++++
 gather.sh            |  25 +++++
 gathergcno.sh        |  18 +++
 genPGOKernel         | 107 ++++++++++++++++++
 processGCOVMakefiles |   3 +
 rename.sh            |   4 +
 7 files changed, 448 insertions(+)
 create mode 100755 buildGCOVKernel
 create mode 100644 calcsum-4.9.cpp
 create mode 100755 gather.sh
 create mode 100755 gathergcno.sh
 create mode 100755 genPGOKernel
 create mode 100755 processGCOVMakefiles
 create mode 100755 rename.sh

diff --git a/buildGCOVKernel b/buildGCOVKernel
new file mode 100755
index 000000000000..ac26016785c4
--- /dev/null
+++ b/buildGCOVKernel
@@ -0,0 +1,35 @@
+#!/bin/bash
+# This script builds an GCOV instumented kernel.
+echo 'Setup instrumented kernel build env'
+KGCCVER=/opt/kgcc-7.0/bin/
+# We need to mount the kernel source in /tmp root to make the profile data path/user agnostic
+# without it gcc fails to consume the generated profile data.
+DIR=$PWD
+mkdir -p /tmp/kernelsrc >/dev/null 2>&1
+[ -f /tmp/kernelsrc/buildGCOVKernel ] || sudo mount --rbind $PWD /tmp/kernelsrc
+[ -f /tmp/kernelsrc/buildGCOVKernel ] || { echo "Failed to link $PWD to /tmp/kernelsrc"; exit 1; }
+
+# Clean-up the mount on exit.
+cleanup() {
+    cd $DIR
+    sudo umount /tmp/kernelsrc
+}
+trap cleanup SIGINT SIGHUP SIGTERM
+
+cd /tmp/kernelsrc
+
+echo 'Enabling kernel profiling in config..'
+make silentoldconfig
+./scripts/config -e CONFIG_GCOV_KERNEL -e CONFIG_GCOV_PROFILE_ALL -e CONFIG_GCOV_FORMAT_6_3 --disable CONFIG_GCOV_PGO_ENABLE
+
+echo 'Building Instrumented Kernel.'
+# Build the kernel with kgcc
+# It is not possible to build instrumented/pgo kernel with distro gcc configuration:
+#   gcc produces invalid code producing 'TLS' references to the gcov variables but kernel-code does not have TLS.
+# Also we are thinking the kernel as one monolith 'program' we are instrumenting.
+make $@  V=2 CC=$KGCCVER/kgcc AR=$KGCCVER/kgcc-ar NM=$KGCCVER/kgcc-nm
+[ $? -eq 0 ] && echo 'Kernel build okay!' || echo 'Kernel build failed. Stop.' && exit 1;
+
+echo 'Collecting GCNO profile files..'
+./gathergcno.sh gcnoprofile.tar.gz
+exit 0
\ No newline at end of file
diff --git a/calcsum-4.9.cpp b/calcsum-4.9.cpp
new file mode 100644
index 000000000000..3c50fb09a69f
--- /dev/null
+++ b/calcsum-4.9.cpp
@@ -0,0 +1,256 @@
+// KPGO Project
+
+#include <stdio.h>
+#include <string>
+#include <vector>
+#include <assert.h>
+
+using namespace std;
+
+static unsigned histogram_index (long long value)
+{
+	unsigned long long v = (unsigned long long)value;
+	unsigned r = 0;
+	unsigned prev2bits = 0;
+	if (v > 0)
+		r = 63 - __builtin_clzll (v);
+	if (r < 2)
+		return (unsigned)value;
+	assert (r < 64);
+	prev2bits = (v >> (r - 2)) & 0x3;
+	return (r - 1) * 4 + prev2bits;
+}
+
+static int read_file(const char *filename, vector<char> &out)
+{
+	FILE *fp = fopen(filename, "rb");
+	if (!fp)
+	{
+		fprintf(stderr, "[!] Fail to read: %s\n", filename);
+		return 1;
+	}
+	char buf[4096];
+	size_t sz;
+	while ((sz = fread(buf, 1, 4096, fp)))
+		out.insert(out.end(), buf, buf + sz);
+	fclose(fp);
+	return 0;
+}
+
+static void split_lines(const vector<char> &in, vector<string> &out)
+{
+	size_t pos = 0;
+	for (size_t i = 0; i < in.size(); ++i)
+	{
+		if (in[i] != '\r' && in[i] != '\n')
+			continue;
+		out.push_back(string(in.begin() + pos, in.begin() + i));
+		if (in[i] == '\r' && i + 1 < in.size() && in[i + 1] == '\n')
+			i++;
+		pos = i + 1;
+	}
+	if (pos < in.size())
+		out.push_back(string(in.begin() + pos, in.end()));
+}
+
+static unsigned num;
+static long long sum_all, max_val;
+struct bucket
+{
+	unsigned num;
+	long long min, sum;
+} histogram[256];
+
+static void histogram_insert(long long value)
+{
+	unsigned i = histogram_index(value);
+	histogram[i].num++;
+	histogram[i].sum += value;
+	if (value < histogram[i].min)
+		histogram[i].min = value;
+}
+
+#define GCOV_DATA_MAGIC		  0x67636461u
+#define GCOV_TAG_FUNCTION		0x01000000u
+#define GCOV_TAG_COUNTER_BASE	0x01a10000u
+#define GCOV_TAG_PROGRAM_SUMMARY 0xa3000000u
+
+int process(const unsigned *v, int n)
+{
+	int state = 1;
+	unsigned count;
+	for (int i = 0; i < n; ++i)
+	{
+		unsigned val = v[i];
+		switch (state)
+		{
+			case 1:
+				if (val != GCOV_DATA_MAGIC)
+				{
+					fprintf(stderr, "[!] GCOV_DATA_MAGIC mismatch: 0x%x\n", val);
+					return 1;
+				}
+				i += 2;
+				state = 2;
+				break;
+			case 2:
+				if (i == n - 1 && val)
+				{
+					fprintf(stderr, "[!] Single last tag: 0x%x\n", val);
+					return 2;
+				}
+				if (val == GCOV_TAG_FUNCTION)
+					i += 1 + v[i + 1];
+				else if (val == GCOV_TAG_COUNTER_BASE)
+				{
+					if (v[i + 1] % 2)
+					{
+						fprintf(stderr, "[!] Invalid length: %d\n", v[i + 1]);
+						return 3;
+					}
+					count = v[i + 1] / 2;
+					num += count;
+					if (count)
+						state = 3;
+					i++;
+				}
+				else if (val)
+				{
+					if (!(val & 0xffff) && ((val - GCOV_TAG_COUNTER_BASE) >> 17) < 9)
+						i += 1 + v[i + 1];
+					else
+					{
+						fprintf(stderr, "[!] Unknown tag: 0x%x\n", val);
+						return 4;
+					}
+				}
+				break;
+			case 3:
+				long long ctr = v[++i];
+				ctr = (ctr << 32) + val;
+				histogram_insert(ctr);
+				sum_all += ctr;
+				if (ctr > max_val)
+					max_val = ctr;
+				if (--count == 0)
+					state = 2;
+				break;
+		}
+		if (i >= n)
+		{
+			fprintf(stderr, "[!] Overflow\n");
+			return 5;
+		}
+	}
+	if (state == 3)
+	{
+		fprintf(stderr, "[!] Overflow\n");
+		return 6;
+	}
+	return 0;
+}
+
+unsigned mask[8], hcount = 0;
+
+int write_file(const vector<char> in, const char *filename)
+{
+	if (in.size() < 12)
+	{
+		fprintf(stderr, "[!] Not enough to write\n");
+		return 1;
+	}
+	FILE *fp = fopen(filename, "wb");
+	if (!fp)
+	{
+		fprintf(stderr, "[!] Fail to write: %s\n", filename);
+		return 2;
+	}
+	// set the gcov version in format "603*" aka gcc 6.3.*
+	// the magic value is simply "*306" string casted to uint32_t
+	// or picked from the gcc error message.
+	// I have not yet figured out where kernel registers the
+	// GCC version or how to change it automatically per build.
+	unsigned int gcov_version = 1094136106;
+	fwrite(in.data(), 1, 4, fp);
+	fwrite(&gcov_version, 1, 4, fp);
+	fwrite(in.data()+8, 1, 4, fp);
+
+	unsigned tmp[11] = {
+		GCOV_TAG_PROGRAM_SUMMARY,
+		17 + hcount * 5,
+		0,
+		num,
+		1,
+		(unsigned)sum_all,
+		(unsigned)(sum_all >> 32),
+		(unsigned)max_val,
+		(unsigned)(max_val >> 32),
+		(unsigned)max_val,
+		(unsigned)(max_val >> 32)
+	};
+	fwrite(tmp, 1, 44, fp);
+	fwrite(mask, 1, 32, fp);
+	for (int i = 0; i < 256; ++i)
+	{
+		if (histogram[i].num <= 0)
+			continue;
+		unsigned tmp2[5] = {
+			histogram[i].num,
+			(unsigned)(histogram[i].min),
+			(unsigned)(histogram[i].min >> 32),
+			(unsigned)(histogram[i].sum),
+			(unsigned)(histogram[i].sum >> 32)
+		};
+		fwrite(tmp2, 1, 20, fp);
+	}
+	fwrite(in.data() + 12, 1, in.size() - 12, fp);
+	fclose(fp);
+	return 0;
+}
+
+int main(int argc, char **argv)
+{
+	vector<char> content;
+	if (argc != 2 || read_file(argv[1], content))
+	{
+		fprintf(stderr, "USAGE:\n  %s <Input File List>\n", argv[0]);
+		return 1;
+	}
+	for (int i = 0; i < 256; ++i)
+		histogram[i].min = 0x7fffffffffffffffll;
+	vector<string> lines;
+	split_lines(content, lines);
+	vector<vector<char> > v(lines.size());
+	for (size_t i = 0; i < lines.size(); ++i)
+	{
+		const char *filename = lines[i].c_str();
+		if (read_file(filename, v[i]))
+			return 2;
+		if (v[i].size() % 4)
+		{
+			fprintf(stderr, "[!] File size mismatch: %s\n", filename);
+			return 3;
+		}
+		fprintf(stderr, "[.] Processing %s\n", filename);
+		if (process((const unsigned *)v[i].data(), v[i].size() / 4))
+			return 4;
+	}
+	fprintf(stderr, "[.] num: %d\n", num);
+	fprintf(stderr, "[.] sum_all: %lld\n", sum_all);
+	fprintf(stderr, "[.] max_val: %lld\n", max_val);
+	for (int i = 0; i < 256; ++i)
+	{
+		if (histogram[i].num <= 0)
+			continue;
+		hcount++;
+		mask[i / 32] |= 1 << (i % 32);
+		fprintf(stderr, "[.] histogram(%03d): num=%d, min=%lld, sum=%lld\n", i, histogram[i].num, histogram[i].min, histogram[i].sum);
+	}
+	for (size_t i = 0; i < lines.size(); ++i)
+	{
+		if (write_file(v[i], lines[i].c_str()))
+			return 5;
+	}
+	fprintf(stderr, "[.] Files processed: %d\n", (int)lines.size());
+	return 0;
+}
diff --git a/gather.sh b/gather.sh
new file mode 100755
index 000000000000..12272f64a85c
--- /dev/null
+++ b/gather.sh
@@ -0,0 +1,25 @@
+#!/bin/bash -e
+
+DEST=$1
+GCDA=/sys/kernel/debug/gcov
+
+if [ ! -d "$GCDA" ] ; then
+  echo "mount -t debugfs none /sys/kernel/debug"
+  exit 1
+fi
+
+if [ -z "$DEST" ] ; then
+  echo "Usage: $0 <output.tar.gz>" >&2
+  exit 1
+fi
+
+TEMPDIR=$(mktemp -d)
+echo Collecting data..
+find $GCDA -type d -exec mkdir -p $TEMPDIR/\{\} \;
+find $GCDA -name '*.gcda' -exec sh -c 'cat < $0 > '$TEMPDIR'/$0' {} \;
+#find $GCDA -name '*.gcno' -exec sh -c 'cp -d $0 '$TEMPDIR'/$0' {} \;
+tar czf $DEST -C $TEMPDIR .
+rm -rf $TEMPDIR
+
+echo "$DEST successfully created, copy to build system and unpack with:"
+echo "  tar xfz $DEST"
diff --git a/gathergcno.sh b/gathergcno.sh
new file mode 100755
index 000000000000..b407f4a1b1cb
--- /dev/null
+++ b/gathergcno.sh
@@ -0,0 +1,18 @@
+#!/bin/bash -e
+# Store all gcno files generated by the compiler.
+# .gcno files are needed by lcov tool to view the profile data.
+# both .gcno and .gcda files *must* be from exactly same build or
+# lcov won't work.
+DEST=$1
+
+TEMPDIR=$(mktemp -d)
+
+echo "Collecting GCNO compiler data.."
+
+find . \( -path ./.git -o -path ./Documentation -o -path ./samples -o -path ./scripts -o -path ./tools \) -prune -o -type d -exec mkdir -p $TEMPDIR/\{\} \;
+find . \( -path ./.git -o -path ./Documentation -o -path ./samples -o -path ./scripts -o -path ./tools \) -prune -o -name '*.gcno' -exec sh -c 'cp -d $0 '$TEMPDIR'/$0' {} \;
+tar czf $DEST -C $TEMPDIR .
+rm -rf $TEMPDIR
+
+echo "$DEST successfully created, unpack with:"
+echo "  tar xfz $DEST"
diff --git a/genPGOKernel b/genPGOKernel
new file mode 100755
index 000000000000..377771a9104e
--- /dev/null
+++ b/genPGOKernel
@@ -0,0 +1,107 @@
+#!/bin/bash -e
+# Process kernel gcov profile data
+# and mangle it for consumption by PGO build
+# the kernel is built after this.
+
+KGCCVER=/opt/kgcc-7.0/bin/
+echo 'Initializing kernel PGO optimization..'
+DIR=$PWD
+mkdir -p /tmp/kernelsrc
+[ -f /tmp/kernelsrc/genPGOKernel ] || sudo mount --rbind $DIR /tmp/kernelsrc
+cd /tmp/kernelsrc
+
+die() {
+    echo $1;
+    exit 1;
+}
+
+# clean-up any mountpoint(s) on error.
+cleanup() {
+    cd $DIR
+    sudo umount /tmp/kernelsrc
+}
+trap cleanup SIGINT SIGHUP SIGTERM
+
+echo 'Checking profile data..'
+if [ ! -f profile.tar.gz ]; then
+    echo "Missing profile.tar.gz GCDA data!"
+    die "It must be created with `gather.sh profile.tar.gz` on the instrumented system"
+fi
+
+if [ ! -f gcnoprofile.tar.gz ]; then
+    echo "Missing gcnoprofile.tar.gz GCNO data!"
+    die "It should be created by `gathergcno.sh gcnoprofile.tar.gz` after successful buildGCOVKernel run"
+fi
+echo 'Extracting profile data..'
+CHECKPROF=/tmp/kernelPGOdump/sys/kernel/debug/gcov/tmp/kernelPGO/
+if [ ! -f $CHECKPROF/mm/.tmp_mmap.gcda ]; then
+    rm -fr /tmp/kernelPGOdump
+    mkdir /tmp/kernelPGOdump
+
+    tar xzf profile.tar.gz -C /tmp/kernelPGOdump
+    tar xzf gcnoprofile.tar.gz -C .
+    if [ ! -f $CHECKPROF/mm/mmap.gcda  ]; then
+        die 'No Kernel profiling data available. Stop.'
+    fi
+
+    echo 'Postprocesing profile data with calcsum..'
+    find /tmp/kernelPGOdump -name '*.gcda' > list.txt
+    ./calcsum list.txt >/dev/null
+    rm -f list.txt
+
+    # run gcov-tool rewrite -s 1.0
+    # this is effectively a no-op but ensures the profile data is valid.
+    # the tool appeared in gcc 6.1 and seems to be able fixup
+    # any missing info in the gcda files.
+    # It is bit unclear is calcsum still required: gcov-tool seems to do
+    # exactly same thing as calcsum.
+    echo 'Postprocesing profile data with kgcov-tool..'
+    $KGCCVER/kgcov-tool rewrite -s 1.0 -o /tmp/kernelPGOdump/ /tmp/kernelPGOdump/
+
+    echo 'Adjusting profile data file names..'
+    find /tmp/kernelPGOdump/* -name '*.gcda' -print0 | xargs -0 -n1 -P0 ./rename.sh
+
+else
+    echo 'NOTE: Using previously configured profile data.'
+fi
+
+echo 'Binding profile data dir..'
+mkdir -p /tmp/kernelPGO/
+if [ ! -f '/tmp/kernelPGO/mm/.tmp_mmap.gcda' ]; then
+    sudo mount --rbind /tmp/kernelPGOdump/sys/kernel/debug/gcov/tmp/kernelPGO /tmp/kernelPGO
+fi
+
+cleanup2() {
+    cleanup;
+    sudo umount /tmp/kernelPGO
+}
+trap cleanup2 SIGINT SIGHUP SIGTERM
+
+# abort if no profile data.
+if [ ! -f '/tmp/kernelPGO/mm/.tmp_mmap.gcda' ]; then
+    die 'Final Profile data missing. Stop.'
+fi
+
+echo 'Disabling kernel profiling in config and building in PGO mode.'
+
+# Note: GCOV_PGO_ENABLE Kconfig option must be enabled to use
+# the profile data in build. This option was necessary as Kbuild must
+# be able to override any default PGO enabled build options.
+./scripts/config --disable CONFIG_GCOV_KERNEL --disable CONFIG_GCOV_PROFILE_ALL --enable CONFIG_GCOV_PGO_ENABLE
+
+# remove old build logs
+{
+mv -f build.log build.log.old || true
+mv -f optimize.log optimize.log.old || true
+} >/dev/null 2>&1
+
+echo 'Building final Profile optimized kernel.'
+echo 'See optimize.log for applied optimizations so far.'
+echo 'See build.log for normal KBuild log so far.'
+taskset -pc 0-7 $$ >/dev/null
+{
+make $@ V=2 CC=$KGCCVER/kgcc AR=$KGCCVER/kgcc-ar NM=$KGCCVER/kgcc-nm KCFLAGS="-fopt-info-optall=optimize.log";
+} >build.log 2>&1
+
+echo "Build of profile optimized kernel is done."
+cd $DIR
diff --git a/processGCOVMakefiles b/processGCOVMakefiles
new file mode 100755
index 000000000000..92a4a4eb22fe
--- /dev/null
+++ b/processGCOVMakefiles
@@ -0,0 +1,3 @@
+#!/bin/sh
+# big pipeline to add 'GCOV_PROFILE := n' where equalent 'KCOV_INSTRUMENT' is set.
+find . -path ./.git -prune  -o -name 'Makefile' -print0 | xargs -0 sed -i 's#KCOV_INSTRUMENT\(.*\)#KCOV_INSTRUMENT\1\nGCOV_PROFILE\1#g'
diff --git a/rename.sh b/rename.sh
new file mode 100755
index 000000000000..08976de7feda
--- /dev/null
+++ b/rename.sh
@@ -0,0 +1,4 @@
+#!/bin/sh
+RN=$(echo "$1" | sed -ne 's#\(.*\)\/\(.*\)#\1/.tmp_\2#p')
+cp "$1" "${RN}"
+rm "$1"
-- 
2.19.2

