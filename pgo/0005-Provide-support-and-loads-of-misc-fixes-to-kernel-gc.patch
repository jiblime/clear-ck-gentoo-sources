From 1257f391abc8afa54eb7a88b6cc09ec02bdde921 Mon Sep 17 00:00:00 2001
From: Jarmo Tiitto <jarmo.tiitto@gmail.com>
Date: Thu, 3 May 2018 20:05:27 +0300
Subject: [PATCH 05/21] Provide support and loads of misc fixes to kernel gcov
 system. This commit begins rewriting the kernel/gcov system for FDO builds.
 Changes include: 	* Fixup instrumented build with GCC 6.3. 	*
 GCOV_COUNTER_xxx macros to operate on gcov profile variables. 	* _atomic
 variants of the profiling machinery. (v1) 	* More stable profile data
 output, each outputed gcda debugfs file is printed into dmesg. 	* Code
 to support gcc __gcov_topn_value_profiler. It is not used yet tough by GCC.

---
 Makefile              |  17 ++++
 kernel/gcov/Kconfig   |  15 ++++
 kernel/gcov/Makefile  |   4 +
 kernel/gcov/base.c    | 201 +++++++++++++++++++++++++++++++++++-------
 kernel/gcov/gcc_4_7.c |   8 +-
 kernel/gcov/gcc_4_9.c | 158 ++++++++++++++++++++++++++-------
 kernel/gcov/gcov.h    |  41 ++++++++-
 7 files changed, 374 insertions(+), 70 deletions(-)

diff --git a/Makefile b/Makefile
index 20cbb8e84650..9800f81aba97 100644
--- a/Makefile
+++ b/Makefile
@@ -398,6 +398,7 @@ LDFLAGS_MODULE  =
 CFLAGS_KERNEL	=
 AFLAGS_KERNEL	=
 LDFLAGS_vmlinux =
+CFLAGS_GCOV	= -fprofile-generate -fprofile-update=atomic $(call cc-disable-warning,maybe-uninitialized,)
 
 # Use USERINCLUDE when you must reference the UAPI directories only.
 USERINCLUDE    := \
@@ -423,6 +424,22 @@ KBUILD_CFLAGS   := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
 		   -Wno-format-security \
 		   -std=gnu89
 KBUILD_CPPFLAGS := -D__KERNEL__
+
+# Enable GCC PGO optimizations if requested.
+ifdef CONFIG_GCOV_PGO_ENABLE
+KBUILD_CFLAGS	+= -finline-functions -fprofile-reorder-functions \
+		   -fprofile-use=/tmp/kernelPGO -fprofile-correction \
+		   -fprofile-dir=/tmp/kernelPGO \
+		   -Wcoverage-mismatch -Wno-error=coverage-mismatch \
+		   -fno-tree-vectorize -fno-tree-loop-im
+endif
+
+ifdef CONFIG_GCOV_KERNEL
+    LDFLAGS_MODULE	+= $(call cc-option,-fprofile-generate) \
+			$(call cc-option,-fprofile-update=atomic)
+    LDFLAGS_vmlinux	+= $(call cc-option,-fprofile-generate) \
+			$(call cc-option,-fprofile-update=atomic)
+endif
 KBUILD_AFLAGS_KERNEL :=
 KBUILD_CFLAGS_KERNEL :=
 KBUILD_AFLAGS_MODULE  := -DMODULE
diff --git a/kernel/gcov/Kconfig b/kernel/gcov/Kconfig
index 4ecf88c10f0e..2a803fc45f07 100644
--- a/kernel/gcov/Kconfig
+++ b/kernel/gcov/Kconfig
@@ -1,5 +1,15 @@
 menu "GCOV-based kernel profiling"
 
+config GCOV_PGO_ENABLE
+	bool "Enable Profile guided optimization kernel build."
+	default n
+	---help---
+	This option enables gcov-profile based build optimizations.
+	Kernel must have been first instrumented and gcov-profile data
+	must be available at /tmp/kernelPGO.
+	This enables -fprofile-use=/tmp/kernelPGO gcc flag.
+	Very experimental.
+
 config GCOV_KERNEL
 	bool "Enable gcov-based kernel profiling"
 	depends on DEBUG_FS
@@ -76,6 +86,11 @@ config GCOV_FORMAT_4_9
 	---help---
 	Select this option to use the format defined by GCC 4.9.
 
+config GCOV_FORMAT_6_3
+	bool "GCC 6.3 format"
+	---help---
+	Select this option to use the format defined by GCC 6.3.
+
 endchoice
 
 endmenu
diff --git a/kernel/gcov/Makefile b/kernel/gcov/Makefile
index 638827259852..853622665571 100644
--- a/kernel/gcov/Makefile
+++ b/kernel/gcov/Makefile
@@ -14,6 +14,8 @@ else ifeq ($(CONFIG_GCOV_FORMAT_4_7),y)
   cc-ver := 0407
 else ifeq ($(CONFIG_GCOV_FORMAT_4_9),y)
   cc-ver := 0409
+else ifeq ($(CONFIG_GCOV_FORMAT_6_3),y)
+  cc-ver := 0603
 else
 # Use cc-version if available, otherwise set 0
 #
@@ -35,6 +37,8 @@ ifeq ($(call if-lt, $(cc-ver), 0407),1)
   obj-$(CONFIG_GCOV_KERNEL) += gcc_3_4.o
 else ifeq ($(call if-lt, $(cc-ver), 0409),1)
   obj-$(CONFIG_GCOV_KERNEL) += gcc_4_7.o
+else ifeq ($(call if-lt, $(cc-ver), 0603),1)
+  obj-$(CONFIG_GCOV_KERNEL) += gcc_4_9.o
 else
   obj-$(CONFIG_GCOV_KERNEL) += gcc_4_9.o
 endif
diff --git a/kernel/gcov/base.c b/kernel/gcov/base.c
index 5c995e4e8a8b..2d518af464a1 100644
--- a/kernel/gcov/base.c
+++ b/kernel/gcov/base.c
@@ -63,6 +63,12 @@ void __gcov_flush(void)
 }
 EXPORT_SYMBOL(__gcov_flush);
 
+void __gcov_exit(void)
+{
+	/* Unused. */
+}
+EXPORT_SYMBOL(__gcov_exit);
+
 void __gcov_merge_add(gcov_type *counters, unsigned int n_counters)
 {
 	/* Unused. */
@@ -94,20 +100,22 @@ void __gcov_merge_time_profile(gcov_type *counters, unsigned int n_counters)
 EXPORT_SYMBOL(__gcov_merge_time_profile);
 
 static inline void __gcov_one_value_profiler_body(gcov_type *counters,
-						  gcov_type value)
+						  gcov_arg value)
 {
-	if (value == counters[0]) {
-		counters[1]++;
-	} else if (counters[1] == 0) {
-		counters[1] = 1;
-		counters[0] = value;
+	gcov_arg val = GCOV_COUNTER_READ(counters+1);
+	gcov_arg tst = GCOV_COUNTER_READ(counters);
+	if( tst == value) {
+		GCOV_COUNTER_INC(counters+1);
+	} else if (val == 0) {
+		if(GCOV_COUNTER_CMPXCHG(counters+1, val, 1) == val)
+			GCOV_COUNTER_CMPXCHG(counters, tst, value);
 	} else {
-		counters[1]--;
+		GCOV_COUNTER_DEC(counters+1);
 	}
-	counters[2]++;
+	GCOV_COUNTER_INC(counters+2);
 }
 
-void __gcov_indirect_call_profiler(gcov_type *counter, gcov_type value,
+void __gcov_indirect_call_profiler(gcov_type *counter, gcov_arg value,
 				   void *cur_func, void *callee_func)
 {
 	if (cur_func == callee_func)
@@ -120,7 +128,7 @@ EXPORT_SYMBOL(__gcov_indirect_call_callee);
 gcov_type *__gcov_indirect_call_counters;
 EXPORT_SYMBOL(__gcov_indirect_call_counters);
 
-void __gcov_indirect_call_profiler_v2(gcov_type value, void *cur_func)
+void __gcov_indirect_call_profiler_v2(gcov_arg value, void *cur_func)
 {
 	if (cur_func == __gcov_indirect_call_callee)
 		__gcov_one_value_profiler_body(__gcov_indirect_call_counters,
@@ -128,61 +136,194 @@ void __gcov_indirect_call_profiler_v2(gcov_type value, void *cur_func)
 }
 EXPORT_SYMBOL(__gcov_indirect_call_profiler_v2);
 
-static gcov_type function_counter;
+static gcov_type function_counter = { 0 };
 
 void __gcov_time_profiler(gcov_type *counters)
 {
-	if (!counters[0])
-		counters[0] = ++function_counter;
+	gcov_arg fcnt = GCOV_COUNTER_READ(&function_counter);
+	gcov_arg tst = GCOV_COUNTER_READ(counters);
+	if(!tst) {
+		if(GCOV_COUNTER_CMPXCHG(counters, tst, fcnt + 1) == tst)
+			GCOV_COUNTER_INC(&function_counter);
+	}
 }
 EXPORT_SYMBOL(__gcov_time_profiler);
 
-void __gcov_ior_profiler(gcov_type *counters, gcov_type value)
+/* atomic variant export */
+void __gcov_time_profiler_atomic(gcov_type *counters)
 {
-	*counters |= value;
+	__gcov_time_profiler(counters);
+}
+EXPORT_SYMBOL(__gcov_time_profiler_atomic);
+
+void __gcov_ior_profiler(gcov_type *counters, gcov_arg value)
+{
+	GCOV_COUNTER_BITOR(counters, value);
 }
 EXPORT_SYMBOL(__gcov_ior_profiler);
 
-void __gcov_average_profiler(gcov_type *counters, gcov_type value)
+/* atomic variant export */
+void __gcov_ior_profiler_atomic(gcov_type *counters, gcov_arg value)
 {
-	counters[0] += value;
-	counters[1]++;
+	__gcov_ior_profiler(counters, value);
+}
+EXPORT_SYMBOL(__gcov_ior_profiler_atomic);
+
+void __gcov_average_profiler(gcov_type *counters, gcov_arg value)
+{
+	GCOV_COUNTER_ADD(counters, value);
+	GCOV_COUNTER_INC(counters);
 }
 EXPORT_SYMBOL(__gcov_average_profiler);
 
-void __gcov_one_value_profiler(gcov_type *counters, gcov_type value)
+/* atomic variant export */
+void __gcov_average_profiler_atomic(gcov_type *counters, gcov_arg value)
+{
+	__gcov_average_profiler(counters, value);
+}
+EXPORT_SYMBOL(__gcov_average_profiler_atomic);
+
+void __gcov_one_value_profiler(gcov_type *counters, gcov_arg value)
 {
 	__gcov_one_value_profiler_body(counters, value);
 }
 EXPORT_SYMBOL(__gcov_one_value_profiler);
 
-void __gcov_interval_profiler(gcov_type *counters, gcov_type value,
+/* atomic variant export */
+void __gcov_one_value_profiler_atomic(gcov_type *counters, gcov_arg value)
+{
+	__gcov_one_value_profiler_body(counters, value);
+}
+EXPORT_SYMBOL(__gcov_one_value_profiler_atomic);
+
+void __gcov_interval_profiler(gcov_type *counters, gcov_arg value,
 			      int start, unsigned steps)
 {
-	gcov_type delta = value - start;
+	long long delta = value - start;
 	if (delta < 0)
-		counters[steps + 1]++;
+		GCOV_COUNTER_INC(counters + steps + 1);
 	else if (delta >= steps)
-		counters[steps]++;
+		GCOV_COUNTER_INC(counters + steps);
 	else
-		counters[delta]++;
+		GCOV_COUNTER_INC(counters + delta);
 }
 EXPORT_SYMBOL(__gcov_interval_profiler);
 
-void __gcov_pow2_profiler(gcov_type *counters, gcov_type value)
+/* atomic variant export */
+void __gcov_interval_profiler_atomic(gcov_type *counters, gcov_arg value,
+			      int start, unsigned steps)
+{
+	__gcov_interval_profiler(counters, value, start, steps);
+}
+EXPORT_SYMBOL(__gcov_interval_profiler_atomic);
+
+void __gcov_pow2_profiler(gcov_type *counters, gcov_arg value)
 {
 	if (value & (value - 1))
-		counters[0]++;
+		GCOV_COUNTER_INC(counters);
 	else
-		counters[1]++;
+		GCOV_COUNTER_INC(counters+1);
 }
 EXPORT_SYMBOL(__gcov_pow2_profiler);
 
-void __gcov_exit(void)
+/* atomic variant export */
+void __gcov_pow2_profiler_atomic(gcov_type *counters, gcov_arg value)
 {
-	/* Unused. */
+	__gcov_pow2_profiler(counters, value);
 }
-EXPORT_SYMBOL(__gcov_exit);
+EXPORT_SYMBOL(__gcov_pow2_profiler_atomic);
+
+static inline void __gcov_topn_value_profiler_body(gcov_type * counters, gcov_arg value)
+{
+	unsigned int i, j, found = 0, have_zero_count = 0;
+	gcov_type * entry;
+	gcov_type * lfu_entry = counters+1;
+	gcov_type * value_array = counters+1;
+	gcov_type * num_eviction = counters;
+	const unsigned int topn_val = GCOV_ICALL_TOPN_VAL;
+	gcov_type tmp_cnts[GCOV_ICALL_TOPN_VAL];
+	gcov_type * p, minv;
+
+	/* There are 2*topn_val values tracked, each value takes two slots in the
+	  counter array.  */
+	for(i = 0; i < (topn_val << 2); i += 2) {
+		entry = value_array+i;
+		if(GCOV_COUNTER_READ(entry) == value) {
+			GCOV_COUNTER_INC(entry+1);
+			found = 1;
+			break;
+		} else if(GCOV_COUNTER_READ(entry+1) == 0) {
+			lfu_entry = entry;
+			have_zero_count = 1;
+		} else if(GCOV_COUNTER_READ(entry+1) < GCOV_COUNTER_READ(lfu_entry+1)) {
+			lfu_entry = entry;
+		}
+	}
+
+	if(found) {
+		return;
+	}
+
+	/* lfu_entry is either an empty entry or an entry
+	 * with lowest count, which will be evicted.  */
+	GCOV_COUNTER_SET(lfu_entry, value);
+	GCOV_COUNTER_SET(lfu_entry+1, 1);
+
+	#define GCOV_ICALL_COUNTER_CLEAR_THRESHOLD 3000
+
+	/* Too many evictions -- time to clear bottom entries to
+	  avoid hot values bumping each other out.  */
+	if(!have_zero_count
+		&&  GCOV_COUNTER_FETCH_ADD(num_eviction,1)+1 >= GCOV_ICALL_COUNTER_CLEAR_THRESHOLD) {
+
+		GCOV_COUNTER_SET(num_eviction, 0);
+
+		for(i = 0; i < topn_val; i++) {
+			GCOV_COUNTER_SET(tmp_cnts+i, 0);
+		}
+
+		/* Find the largest topn_val values from the group of
+		 * 2*topn_val values and put them into tmp_cnts.  */
+		for(i = 0; i < 2 * topn_val; i += 2) {
+			p = 0;
+			for(j = 0; j < topn_val; j++) {
+				if(!p || GCOV_COUNTER_READ(tmp_cnts+j) < GCOV_COUNTER_READ(p)) {
+					p = tmp_cnts+j;
+				}
+			}
+			if(GCOV_COUNTER_READ(value_array+i + 1) > GCOV_COUNTER_READ(p)) {
+				GCOV_COUNTER_SET(p, GCOV_COUNTER_READ(value_array+i + 1));
+			}
+		}
+
+		minv = tmp_cnts[0];
+		for(j = 1; j < topn_val; j++) {
+			if(GCOV_COUNTER_READ(tmp_cnts+j) < GCOV_COUNTER_READ(&minv)) {
+				minv = tmp_cnts[j];
+			}
+		}
+		/* Zero out low value entries.  */
+		for(i = 0; i < 2 * topn_val; i += 2) {
+			if(GCOV_COUNTER_READ(value_array+i + 1) < GCOV_COUNTER_READ(&minv)) {
+				GCOV_COUNTER_SET(value_array+i, 0);
+				GCOV_COUNTER_SET(value_array+i+1, 0);
+			}
+		}
+	}
+}
+
+gcov_type *__gcov_indirect_call_topn_counters;
+EXPORT_SYMBOL(__gcov_indirect_call_topn_counters);
+void *__gcov_indirect_call_topn_callee;
+EXPORT_SYMBOL(__gcov_indirect_call_topn_callee);
+
+void __gcov_indirect_call_topn_profiler(gcov_arg value, void* cur_func)
+{
+	void *callee_func = __gcov_indirect_call_topn_callee;
+	if (cur_func == callee_func)
+		__gcov_topn_value_profiler_body (__gcov_indirect_call_topn_counters, value);
+}
+EXPORT_SYMBOL(__gcov_indirect_call_topn_profiler);
 
 /**
  * gcov_enable_events - enable event reporting through gcov_event()
diff --git a/kernel/gcov/gcc_4_7.c b/kernel/gcov/gcc_4_7.c
index 612fcb368e7c..e02554f03396 100644
--- a/kernel/gcov/gcc_4_7.c
+++ b/kernel/gcov/gcc_4_7.c
@@ -19,12 +19,10 @@
 #include <linux/vmalloc.h>
 #include "gcov.h"
 
-#if __GNUC__ == 6
-#define GCOV_COUNTERS 10
-#elif __GNUC__ == 5 && __GNUC_MINOR__ >= 1
-#define GCOV_COUNTERS			10
+#if __GNUC__ >= 5 && __GNUC_MINOR__ >= 1
+#define GCOV_COUNTERS			8
 #elif __GNUC__ == 4 && __GNUC_MINOR__ >= 9
-#define GCOV_COUNTERS			9
+#define GCOV_COUNTERS			8
 #else
 #define GCOV_COUNTERS			8
 #endif
diff --git a/kernel/gcov/gcc_4_9.c b/kernel/gcov/gcc_4_9.c
index 106a2fbbbeef..5900cb05df99 100644
--- a/kernel/gcov/gcc_4_9.c
+++ b/kernel/gcov/gcc_4_9.c
@@ -18,8 +18,8 @@
 #include <linux/vmalloc.h>
 #include "gcov.h"
 
-#if __GNUC__ == 6
-#define GCOV_COUNTERS 10
+#if __GNUC__ >= 6
+#define GCOV_COUNTERS			10
 #elif __GNUC__ == 5 && __GNUC_MINOR__ >= 1
 #define GCOV_COUNTERS			10
 #elif __GNUC__ == 4 && __GNUC_MINOR__ >= 9
@@ -220,30 +220,30 @@ static void gcov_merge_add(struct gcov_ctr_info *dst,
 {
 	unsigned int i;
 	for (i = 0; i < src->num; ++i)
-		dst->values[i] += src->values[i];
+		GCOV_COUNTER_ADD(dst->values+i, GCOV_COUNTER_READ(src->values+i));
 }
 
 static void gcov_merge_single(struct gcov_ctr_info *dst,
 			      const struct gcov_ctr_info *src)
 {
 	unsigned int i;
-	gcov_type value, counter, all;
+	gcov_arg value, counter, all;
 	if (src->num % 3)
 		return;
 	for (i = 0; i < src->num; ) {
-		value = src->values[i++];
-		counter = src->values[i++];
-		all = src->values[i++];
+		value = GCOV_COUNTER_READ(src->values + i++);
+		counter = GCOV_COUNTER_READ(src->values + i++);
+		all = GCOV_COUNTER_READ(src->values + i++);
 
-		if (dst->values[0] == value) {
-			dst->values[1] += counter;
-		} else if (counter > dst->values[1]) {
-			dst->values[0] = value;
-			dst->values[1] = counter - dst->values[1];
+		if (GCOV_COUNTER_READ(dst->values) == value) {
+			GCOV_COUNTER_ADD(dst->values+1, counter);
+		} else if (counter > GCOV_COUNTER_READ(dst->values+1)) {
+			GCOV_COUNTER_SET(dst->values, value);
+			GCOV_COUNTER_SET(dst->values+1, counter - GCOV_COUNTER_READ(dst->values+1));
 		} else {
-			dst->values[1] -= counter;
+			GCOV_COUNTER_SUB(dst->values+1, counter);
 		}
-		dst->values[2] += all;
+		GCOV_COUNTER_ADD(dst->values+2, all);
 	}
 }
 
@@ -251,24 +251,24 @@ static void gcov_merge_delta(struct gcov_ctr_info *dst,
 			     const struct gcov_ctr_info *src)
 {
 	unsigned int i;
-	gcov_type value, counter, all;
+	gcov_arg value, counter, all;
 	if (src->num % 4)
 		return;
 	for (i = 0; i < src->num; ) {
 		i++;
-		value = src->values[i++];
-		counter = src->values[i++];
-		all = src->values[i++];
+		value = GCOV_COUNTER_READ(src->values + i++);
+		counter = GCOV_COUNTER_READ(src->values + i++);
+		all = GCOV_COUNTER_READ(src->values + i++);
 
-		if (dst->values[1] == value) {
-			dst->values[2] += counter;
-		} else if (counter > dst->values[2]) {
-			dst->values[1] = value;
-			dst->values[2] = counter - dst->values[2];
+		if (GCOV_COUNTER_READ(dst->values+1) == value) {
+			GCOV_COUNTER_ADD(dst->values+2, counter);
+		} else if (counter > GCOV_COUNTER_READ(dst->values+2)) {
+			GCOV_COUNTER_SET(dst->values+1, value);
+			GCOV_COUNTER_SET(dst->values+2, counter - GCOV_COUNTER_READ(dst->values+2));
 		} else {
-			dst->values[2] -= counter;
+			GCOV_COUNTER_SUB(dst->values+2, counter);
 		}
-		dst->values[3] += all;
+		GCOV_COUNTER_ADD(dst->values+3, all);
 	}
 }
 
@@ -277,17 +277,106 @@ static void gcov_merge_ior(struct gcov_ctr_info *dst,
 {
 	unsigned int i;
 	for (i = 0; i < src->num; ++i)
-		dst->values[i] |= src->values[i];
+		GCOV_COUNTER_BITOR(dst->values+i, GCOV_COUNTER_READ(src->values+i));
 }
 
 static void gcov_merge_time_profile(struct gcov_ctr_info *dst,
 				    const struct gcov_ctr_info *src)
 {
 	unsigned int i;
-	for (i = 0; i < src->num; ++i)
-		if (src->values[i] && (!dst->values[i]
-				|| src->values[i] < dst->values[i]))
-			dst->values[i] = src->values[i];
+	gcov_arg srcval, dstval;
+	for (i = 0; i < src->num; ++i) {
+		srcval = GCOV_COUNTER_READ(src->values+i);
+		dstval = GCOV_COUNTER_READ(dst->values+i);
+		if (srcval && (!dstval || srcval < dstval)) {
+			GCOV_COUNTER_SET(dst->values+i, srcval);
+		}
+	}
+}
+
+/* topn value profiler */
+static inline void gcov_sort_n_vals (gcov_type *value_array, int n)
+{
+	int j, k;
+	gcov_arg cur_ent[2];
+	for (j = 2; j < n; j += 2)
+	{
+		cur_ent[0] = GCOV_COUNTER_READ(value_array+j);
+		cur_ent[1] = GCOV_COUNTER_READ(value_array+j+1);
+		k = j - 2;
+		while (k >= 0 && GCOV_COUNTER_READ(value_array+k+1) < cur_ent[1])
+		{
+			GCOV_COUNTER_SET(value_array+k + 2, GCOV_COUNTER_READ(value_array+k));
+			GCOV_COUNTER_SET(value_array+k + 3, GCOV_COUNTER_READ(value_array+k+1));
+			k -= 2;
+		}
+		GCOV_COUNTER_SET(value_array+k + 2, cur_ent[0]);
+		GCOV_COUNTER_SET(value_array+k + 3, cur_ent[1]);
+	}
+}
+
+/* topn value profiler
+ * The func is heavily modified from gcc 6.1 libgcov-merge.c:
+ * __gcov_merge_icall_topn(gcov_type *counters, unsigned n_counters)
+ */
+static void gcov_merge_icall_topn(struct gcov_ctr_info *dst,
+                            const struct gcov_ctr_info *src)
+{
+	unsigned int i, j, k, m;
+	const unsigned int tmp_size = 2 * (GCOV_ICALL_TOPN_NCOUNTS - 1);
+	gcov_type tmp_array[tmp_size];
+	gcov_type * value_array;
+	gcov_type global_id, call_count;
+	// ignore
+	if(src->num % GCOV_ICALL_TOPN_NCOUNTS)
+		return;
+
+	/* cpy src to dst. */
+	for(i = 0; i < src->num; ++i)
+		dst->values[i] = src->values[i];
+	dst->num = src->num;
+
+	for(i = 0; i < src->num; i += GCOV_ICALL_TOPN_NCOUNTS)
+	{
+		value_array = dst->values + i + 1; /* &counters[i + 1]*/
+
+		for(j = 0; j < tmp_size; j++) {
+			GCOV_COUNTER_SET(tmp_array+j, 0);
+		}
+
+		for(j = 0; j < GCOV_ICALL_TOPN_NCOUNTS - 1; j += 2) {
+			tmp_array[j] = dst->values[j];
+			tmp_array[j + 1] = dst->values [j + 1];
+		}
+
+		/* Skip the number_of_eviction entry.  */
+		i++; /* get_counter*/
+		for(k = 0; k < GCOV_ICALL_TOPN_NCOUNTS - 1; k += 2) {
+			int found = 0;
+			global_id = dst->values[i++];   /* get_counter*/
+			call_count = dst->values[i++];  /* get_counter*/
+			for(m = 0; m < j; m += 2) {
+				if(GCOV_COUNTER_READ(tmp_array+m) == GCOV_COUNTER_READ(&global_id)) {
+					found = 1;
+					GCOV_COUNTER_ADD(tmp_array+m + 1, GCOV_COUNTER_READ(&call_count));
+					break;
+				}
+			}
+			if(!found) {
+				tmp_array[j] = global_id;
+				tmp_array[j + 1] = call_count;
+				j += 2;
+			}
+		}
+		/* Now sort the temp array */
+		gcov_sort_n_vals(tmp_array, j);
+
+		/* Now copy back the top half of the temp array */
+		for(k = 0; k < GCOV_ICALL_TOPN_NCOUNTS - 1; k += 2) {
+			dst->values[k] = tmp_array[k];
+			dst->values[k + 1] = tmp_array[k + 1];
+		}
+	}
 }
 
 static const gcov_merge_fn gcov_merge[GCOV_COUNTERS] = {
@@ -299,7 +388,8 @@ static const gcov_merge_fn gcov_merge[GCOV_COUNTERS] = {
 	&gcov_merge_single,
 	&gcov_merge_add,
 	&gcov_merge_ior,
-	&gcov_merge_time_profile
+	&gcov_merge_time_profile,
+	&gcov_merge_icall_topn
 };
 
 /**
@@ -399,6 +489,7 @@ struct gcov_info *gcov_info_dup(struct gcov_info *info)
 
 	return dup;
 err_free:
+	pr_warn("Failed to reserve enough memory for gcov!");
 	gcov_info_free(dup);
 	return NULL;
 }
@@ -546,7 +637,7 @@ static size_t convert_to_gcda(char *buffer, struct gcov_info *info)
 
 			for (cv_idx = 0; cv_idx < ci_ptr->num; cv_idx++) {
 				pos += store_gcov_u64(buffer, pos,
-						      ci_ptr->values[cv_idx]);
+						      GCOV_COUNTER_READ(ci_ptr->values+cv_idx));
 			}
 
 			ci_ptr++;
@@ -565,7 +656,8 @@ static size_t convert_to_gcda(char *buffer, struct gcov_info *info)
 struct gcov_iterator *gcov_iter_new(struct gcov_info *info)
 {
 	struct gcov_iterator *iter;
-
+	/* print notice that we are really doing something. */
+	pr_info("Emiting GCDA for %s", info ? info->filename : "");
 	iter = kzalloc(sizeof(struct gcov_iterator), GFP_KERNEL);
 	if (!iter)
 		goto err_free;
diff --git a/kernel/gcov/gcov.h b/kernel/gcov/gcov.h
index de118ad4a024..a642595788fd 100644
--- a/kernel/gcov/gcov.h
+++ b/kernel/gcov/gcov.h
@@ -16,6 +16,7 @@
 #define GCOV_H GCOV_H
 
 #include <linux/types.h>
+#include <asm/atomic.h>
 
 /*
  * Profiling data types used for gcc 3.4 and above - these are defined by
@@ -27,13 +28,49 @@
 #define GCOV_TAG_COUNTER_BASE	((unsigned int) 0x01a10000)
 #define GCOV_TAG_FOR_COUNTER(count)					\
 	(GCOV_TAG_COUNTER_BASE + ((unsigned int) (count) << 17))
+	
+/* The number of hottest callees to be tracked.  */
+#define GCOV_ICALL_TOPN_VAL  2
+ 
+/* The number of counter entries per icall callsite.  */
+#define GCOV_ICALL_TOPN_NCOUNTS (1 + GCOV_ICALL_TOPN_VAL * 4)
 
+/*
+ * To make PGO optimized kernel stable, kgcov profiling code
+ * must be thread-safe. This means using atomic operations
+ * to when operating on the counters.
+ */
 #if BITS_PER_LONG >= 64
-typedef long gcov_type;
+typedef atomic64_t gcov_type;
+typedef long long gcov_arg;
+#define GCOV_COUNTER_READ(X) atomic64_read((X))
+#define GCOV_COUNTER_SET(X, A) atomic64_set((X), (A))
+#define GCOV_COUNTER_INC(X) atomic64_inc((X))
+#define GCOV_COUNTER_DEC(X) atomic64_dec((X))
+#define GCOV_COUNTER_ADD(X, A) atomic64_add((A), (X))
+#define GCOV_COUNTER_SUB(X, A) atomic64_sub((A), (X))
+#define GCOV_COUNTER_FETCH_ADD(X, A) atomic64_fetch_add((A), (X))
+#define GCOV_COUNTER_FETCH_SUB(X, A) atomic64_fetch_sub((A), (X))
+#define GCOV_COUNTER_BITOR(X, A) atomic64_or((A), (X))
+#define GCOV_COUNTER_CMPXCHG(X, B, A) atomic64_cmpxchg((X), (B), (A))
 #else
-typedef long long gcov_type;
+typedef atomic_t gcov_type;
+typedef long gcov_arg;
+#define GCOV_COUNTER_READ(X) ((gcov_type) atomic_read((atomic_t*)&(X)))
+#define GCOV_COUNTER_SET(X, A) atomic_set((atomic_t*)&(X), (A))
+#define GCOV_COUNTER_INC(X) atomic_inc((atomic_t*)&(X))
+#define GCOV_COUNTER_DEC(X) atomic_dec((atomic_t*)&(X))
+#define GCOV_COUNTER_ADD(X, A) atomic_add((A), (atomic_t*)&(X))
+#define GCOV_COUNTER_SUB(X, A) atomic_sub((A), (atomic_t*)&(X))
+#define GCOV_COUNTER_FETCH_ADD(X, A) atomic_fetch_add((A), (atomic_t*)&(X))
+#define GCOV_COUNTER_FETCH_SUB(X, A) atomic_fetch_sub((A), (atomic_t*)&(X))
+#define GCOV_COUNTER_BITOR(X, A) atomic_or((A), (atomic_t*)&(X))
+#define GCOV_COUNTER_CMPXCHG(X, B, A) atomic64_cmpxchg((X), (B), (A))
+
 #endif
 
+
+
 /* Opaque gcov_info. The gcov structures can change as for example in gcc 4.7 so
  * we cannot use full definition here and they need to be placed in gcc specific
  * implementation of gcov. This also means no direct access to the members in
-- 
2.19.2

